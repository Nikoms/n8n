keeping your automated acceptance test running when your system is under development is hard separation of concerns can help let's find out how in this episode i'm going to describe how to write acceptance tests that don't break as your system changes i'm going to describe my preferred four-layer approach to organizing the test cases that we write and the infrastructure that supports them keep a lookout for my free guide to acceptance testing described later in the video hi i'm dave farley of continuous delivery welcome to my channel if you haven't already please hit subscribe and if you think it appropriate like the video acceptance tests are always written from the perspective of an external user of the system we're trying to separate how the system works from what we would like it to do our focus is on the what in this in this kind of testing in brian merrick's excellent model these are tests that are business facing and support programming so these are the this is the focus for our for this episode when written before the code and uses executable specifications they're a fantastic tool to drive development so we want to evaluate our system in life-like scenarios from the perspective of an external user of the system executed in production-like test environments this sounds great but people have been trying to do this for years except for the executable specification bit perhaps but on the whole they've done this with poor results so how can we do better how can we solve the problem of these big more complicated tests these tests are genuinely complex we're trying to start up a whole system in a life like a test environment and so these tests can be very fragile if not written well when the system changes the problem is is that the nearly always cause the test to fail that's kind of inevitable at one level if the tests are asserting behavior and the behavior of the system changes fair enough but even small changes can often cause breakages so we need to think about ways in which we can tackle the fragility of these more complicated tests i spoke about a key idea in this separation in an earlier video which you can see here separating what the system should do from how it does it but how do we achieve that let's walk through a simple example and look at this in a bit more detail than we did last time imagine that our job is to test buying a book from amazon that's our use case that's what we're going to explore today the first thing that we would like to do is we'd probably like a requirement that captures that use case so here's our requirement we'd like to be able to pay for books with a credit card so that's our starting point now let's imagine how we're going to take that requirement that user story and turn that into an executable specification and acceptance test that evaluates what we'd like the system to do so let's imagine somebody doing that let's imagine somebody buying a book what are the steps that they would go through in order to buy the book well first they go to the store then they're going to search for a book called continuous delivery in our example they're going to put the book into the shopping cart they're going to go to the checkout they're going to pay for the book with their credit card and now they own the book that's it that's the specification that's the story so that's my test case that's that's what i'm going to create so here's an example of the executable specification we're going to search for a book called continuous delivery we're going to select a book from the the the search for list because there'll probably be more than one book with continuous delivery in the title so, we're, going to, look, for, one, with, the name of the author then we're going to add the selected book to the shopping basket check out go to the checkout and check out the uh with that book and assert at the end that the item has been purchased i'd like to point out that even though what i'm showing here is written in java it's being organized in a way that says nothing at all about how the system works this is not a technical test this is wholly focused on what the system does and says nothing at all on about how the system should work this is almost exactly the same language that i used when i was outlining the steps in my example but lightly rearranged so that it can be computable now i my preference in implementing these sorts of tests is to use a thing called an internal dsl that's a deer cell hosted in a regular programming language and then i get to use all of the tools of my programming language so in this example java but that doesn't stop you using the same techniques with an external dsl that's where you have an explicitly different language something like the gurken language within cucumber or spec flow is a good example of that you can apply the all of the ideas i'm describing here in those other approaches but my examples are going to be based on an internal dsl the example says nothing about how the system works so if our test cases look like this how can we make the rest of them work if they're so abstract the next layer down is the dsl itself the implementation of the domain specific specific language that is designed to make it easy to encode and capture our test cases it provides access to a collection of behaviors that we're going to require of those test cases and is shared between them so we get good reuse if we are going to go to the store in one user story one acceptance test one executable specification and we're going to do the same thing in another one we'll call on the same method in the dsl that goes to the store so we can invest the effort to make sure that the work that it takes to actually go to the store is repeatable and deterministic and works effectively here's a simple example of the next layer down this is a checkout example and in this example we're putting some optional param optimal optional parameters in place and we're parsing the inputs so that we can decide the value of various things and then we're calling down to the to the next layer at the end the the dsl provides default values creates aliases for uh for for names in the system so that we can run the test repeater repeatedly and have different real names in the system but the test has a handle a variable that it can use to interact with it it it allows us to generally it's aimed at making it easy to write test cases that's really what we're trying to achieve with the dsl the dsl then calls into the next layer down the third layer in my four layer architecture is i call the protocol driver layer please note that at the point at which we call down into that layer we're still using the language of the problem domain we are still talking in terms of checkout so the interface to the protocol driver is still high level and abstract the job of the protocol driver though is to start translating these ideas into real interactions with the system under test we're going to take the language of the problem domain and turn that into real interactions uh if you want to test through the ui you maybe you'll use something like selenium in this layer to go and drive a web-based ui if your application exposes a an api as part of its usual interface then maybe you will be translating into calls into that api if your application responds to messages maybe you'll be generating message whatever the natural interface your system is that's going to be the output from the protocol driver layer those are going to be the real interactions with your system think for a minute what that means it means that the only part of our test infrastructure that understands the detail of how your system works is in the protocol driver layer that is hidden completely from the test cases in the test cases you don't say things like search for this box or click on this button you say buy a book put the book in the shopping cart the protocol driver understands what it needs to do at the bottom of the stack of my four-layer stack is the system under test itself and of course that's going to be deployed in a production-like test environment we're going to evaluate that in these life-like scenarios through these executable specifications and test cases the four layer approach is exceedingly powerful it's exceedingly capable and it gives us such a high level of abstraction that we can do some quite interesting and sophisticated things with it think for a moment about my test case consider the example that i've we've just worked through here it is again now read that what does this have to say about amazon it has nothing to say about amazon this test case would be equally true of any of the bookstore this would even be true of a real world bookstore in the amazon example the protocol drivers are going to do stuff like this they're going to interact with the web page they're going to use in this case loose selenium to find the right field to enter data in and so on in order to be able to bridge the gap between the dsl and the functioning of the system that we're trying to test protocol drivers though are the only part of the test and the test infrastructure that know anything about how the system works this separation of concerns is enormously useful with this level of separation we could equally well imagine the protocol driver driving a real robot around a real store without changing anything in the test case here's my example we go to the store we search for a book we put the book in the shopping cart when we go to the checkout we pay with our credit card and now we own the book this separation of concerns is so powerful that it means that you can write the test cases once and then reuse them in different scenarios through different interfaces in different in different interactions it means that you can include encode complicated setup mechanisms in the in the dsl to get your system under test into the right state for you to verify things i've been applying this approach in often complicated systems for many years now and i haven't yet found a an environment where this wasn't a really great way of keeping those test cases focused on what the system needed to do rather than how it did it to recap the four layers are the test cases themselves in the language of the problem domain only talking about what the system needs to do the dsl which allows us to put in uh optional parameters to be very precise in in our specification of a case or very vague if we're trying to move quickly it's optimized to allow us to write the test cases quickly and efficiently the protocol drivers that translate from that abstract language of the problem domain into the language of the system so that we can interact with the system and actually test it and then at the bottom of the stack the system under test itself that we're evaluating i tend to prefer internal dsls like the examples shown here but you can implement this with just as easily in a regular bdd style dsl cucumber or spec flow work very nicely with this separation of concerns but the key idea is to treat the dsl as a thing in its own right and to abstract that and share it and reuse it don't write write your scenarios from scratch every single times or your feature steps every single time use the dsl and and it's it's a much more effective way of being able to write these things very quickly and very efficiently the code and a bit more from my are available in github i'll put a link in the description below so you can take a look at it it's not complete i'm not really trying to test amazon but it demonstrates the ideas and it demonstrates the separation of concerns if you'd like a copy of my free guide to acceptance testing check out the details below thank you very much for watching [Music]