right good morning um I'm going to start on time which obviously has no bearing on whether or not I finish on time uh but I I will try I am also keenly aware that we're going to head into lunch um actually I'm going to make you slightly hungry partway through yeah hungry for knowledge that's what we're here for right okay so uh my name is Kevin Henny I want to talk to you about technical neglect um you already know what technical neglect is but you just haven't had a name for it and naming things is surprisingly important when it comes to communication and being able to reason about the challenges in our codebases the difficulties that we have in architectures that have been around for more than maybe five minutes um and our ability to deal with that or not deal with that that appears to be the problem and part of our problem is that we misidentify the issue the major and and the reason that is is because we have um the stuff we deal with is it's not even slippery software is not slippery because you can't even hold it it's quite insubstantial it's uh the way that I describe it is it's not kickable kiab is clearly a property you often want with h the code but you know you're frustrated so the fact that it's not kickable not physical is actually um kind of a bit of a challenge for us humans who have been fine tuned to the real world which is primarily physical um and so therefore we will look to ways of describing abstract and um uh uh virtual Concepts so neglect is something I'm going to look at here um so my name is Kevin hny I'm an independent consultant trainer and and things uh I used to just put my Twitter handle up there but these days and the fragmentation we've experienced in social media I've just given up here's a shopping list you can find me anywhere um and if we don't have time for questions um obviously you can come up and talk to me afterwards but also feel free to communicate with me on any of these channels although I'm probably less responsive to technical discussions on Instagram um so here's here's here's the thing thing cause and effect the nature of causality is that we have a concept of the time times Arrow which runs from here to here we normally experience an awful lot of this and spend a lot of our time trying to figure out this but it also means that sometimes we confuse things we sometimes misattribute something as a cause when it is actually an effect and the one that I want to talk about here is technical Deb um quick check who who uses this in their conversations at work yeah I'm going to teach you what it means okay um we often attribute technical debt we often say oh that's the problem actually it's an effect the thing we need to be looking at is is the cause now this is not the sole cause of it because it turns out technical debt is not a bad thing it's not intrinsically a bad thing but people normally use that uh use it that way so we need to understand a bit more about technical uh uh debt specifically what we're interested in is the kind of technical debt that falls outside our ability to manage it and is a constant state of surprise but also a constant state of frustration it frustrates our efforts and we'll look at some numbers to see to what degree it does frustrate our efforts and the uh the notion here is that neglect is the cause of a lot of this unmanaged technical debt now why is this such a difficult why why is it such a difficult thing to identify and see why is it that we haven't used the right metaphor the right terms for this well quite simply neglect is a thing that doesn't happen okay we are very good at spotting things that happen oh there's a thing that happened there's another thing that happened okay we can see things that happen we're very good at that and we look for them it's very difficult to notice the absence of something and that is very much the definition of neglect whether it's physical neglect emotional neglect um Urban neglect whatever it is it's a thing that didn't happen it's not a thing that happened you're looking for something that's not there that's why it's so subtle so honestly I can't remember where I took this obviously near a large body of water um but there's a boat it looks kind of abandoned I'm just going to say that it's got a hole in it when we take it out onto the water because we're software developers we take it out onto the water not realizing it's Hardware problems we take it out of the water and that hole well there's water coming in now the boat's going to sink I I'm we're going to solve this in two different ways we are going to solve it first of all as software developers and then we're going to solve it as the rest of humanity you're a software developer and it's kind of like you know what I need to get really good at I need to get good at emptying the boat that's what I need to do there is an effect here it's got right let's work on that getting the water out let's squash those bugs let's all that kind of stuff everybody else is going you know what we don't just want to get the water out but maybe we should stop the water coming in mind blown and this actually was one of those things that came to me a number of years ago um a couple of clients I ran workshops on what to do with a legacy code and you know I'd say those were fairly successful we worked out what to do with it we worked out how to empty in fact that was their focus I was kind of assuming that they would extrapolate that is a mistake I've made so often in my career that you know I'm I'm just excited for the opportunities for me to make that mistake in the next com in the next decade what am I what extrapolation am I going to make that turns out not to be true I am going to give you an extrapolation that I made that does turn out to be true but there is this notion I kind of assumed people I thought it was implicit but it turns out there are a lot of things that are implicit particularly in a software development environment where we're dealing with so much complexity there are so many things happening you can't focus on everything because by definition it's not focus if you're focusing on everything you will let things slip so yes you do need the obvious stated it's a value to all of us but that's the thing I noticed is these people did actually manage particular in one case they managed to do a really good job of dealing with the water in the boat they managed to deal with uh you know have a plan for their legacy the problem is they kept producing Legacy it was a steady state problem is you have to ask yourself the question how do we not do this again what is it that we need to change what causal thing do we need to change to avoid the effect rather than fixing the effect rather than addressing the symptoms now I am being very unkind on software developers but I feel that that's appropriate because you know um you know it's uh uh we're here um and software developers are inherently optimistic people I mean pause for a moment and think about it you wouldn't do it if you didn't have some deep seated sense of optimism but let's start looking at how to reframe our thinking on this and I'm going to go back a few years this is um Mya Layman who published this paper in 1980 which is um quite a long time ago uh and it's kind of interesting because you know if we think from now to 1980 that's that's 44 years if you go back from 1980 44 years that kind of puts you back in a time when Wars didn't even have numbers you know that's the kind of relative distance and still he was making an observation that we find incredibly true still true now as an evolving program is continually changed its complexity reflecting deteriorating structure increases unless work is done to maintain or reduce it now there's a number of points here first of all brilliant observation he was actually making these observations in the 1970s um uh the paper by the way just so that we've got in case you can't see it programs um programs life cycles and law of software Evolution really interesting read um and a lot of ideas nearly half a century later you go oh okay this is quite an old idea but also there's a different ways of thinking things I found this paper to be filled with good ideas that we uh uh that we've somehow um overlooked but he's making a couple of observations here one is the very nature of applying change to a system will degrade its structural quality even and this is kind of implicit so let's make it explicit even if you do a good job of course if you do a bad job it's going to degrade faster so let's let this it's not one of those cases of like oh there's no point in trying because it's always going to get worse no the rate of decline you know if you're applying all your best practices that's certainly going to be a massive Improvement or not but what I'm saying here is that if you are applying all your best practices you will still experience typically a degradation of quality goes back to the idea of focus the idea of focus is you're so busy focusing on this thing whether this thing is this method whether this thing is to introduce this dependency in a way that you find clean and satisfying and comprehensible and you put tests around it and you do all the right things surely there's no degradation of structure there or no opportunity for degradation of structure actually there is because perhaps what you've looked at or not looked at is the larger context because you've been focused remember this is the nature of of attention the idea of attention is that focus is where you put your attention by definition that means you're taking it away from everything else you are ignoring everything else you cannot focus on everything simultaneously so you probably ignore the context you probably ignore the fact that maybe this this dependency introducing this has a conflict or Mak some other dependency redundant okay that's fine you know you know we expect that maybe you'll notice this in 5 minutes maybe you'll notice it in five weeks maybe a colleague of yours will stumble across it in 5 months the point there is even when you're doing the right thing there is still an opportunity for this degradation structure in fact we might actually say this is inherent in physical processes when we do something there is a side effect and we understand that I don't tend to go you know go if I go to the kitchen to make a meal I I do not declare all right I'm going to the kitchen to make a mess there will be a mess I like to think that the mess I create is kind of contained and I tidy as I go more on that later but there will still be a mess I still have to account for the fact that I will need space for dirty dishes that I will need to do the dishes even if it's to put it in as we refer to it at home the dirty dishes cupboard um I will have to do something there the the very process of creating a meal consuming the meal will involve making something dirty it will involve making a mess yes and I'm I'm fine with that you know because that's the way the physical world works you if you've done if you've had any work done on your house you'll know it gets messy before it gets better and it's inherent we assume that as normal we don't do that in software we assume that the work we've just done is the work in its totality we don't allow that little buffer of yeah you got to tidy up you've got to account for well let's give it a term cost of ownership yeah apparently businesses think they can do software for free I think this is beautiful and sweet and tragically economically dumb you can't have code bases and what you can't work on codebases for free if you put in your requirements you also have to deal with the consequences of creating and working with software there is this idea that you have to maintain it let's go back to the dirty dishes covered our dishwasher and in fact other items we might have in the kitchen um and uh adjacent utility spaces a washing machine it needs to be maintained every now and then even our oven needs to be maintained now maintenance he uses the word maintain maintenance is a thing that happens with is is a requirement for physical things because through our interaction with them we they cause that we have wear and tear that's just the way that it works now of course I'm not saying that your code needs maintenance in the runtime I'm not saying that oh you know we've left this binary for a year all the ones have decayed into zeros it's not like that or yeah have you has anybody touched this has anybody touched this source code you know since last year no yeah I've noticed the curly brackets are kind of beginning to fade or fall off to the bottom of the file that's not what I mean it's it's the idea that the interaction that we have with a code to do anything is likely to have these other effects so we have to account for this and this obviously puts us in the space where sometimes I you know we hear this often you may have said it you may have experienced it where somebody say oh our business is prioritizing um you know new requirements over technical work what do they think new requirements are made of pixie dust it's made their new requirements are made of technical stuff all requirements work is technical work there is no such thing as we're not allowed to do technical work because we're working on the requirements unless your requirements live on a white board and never actually have to be deployed at that point yes I concede you can prioritize requirements just not actually getting them into the world getting them into the world is a process that has consequences the problem is We've Ended up misusing the term maintenance we've ended up using the term maintenance to mean fixing bugs well that's just dealing with defects that were always there that's not through where and tear that's not the that's not the advance of time it's broken and it always was from the moment that bug was there until you discovered it 6 months time one year's time it was always there that's not maintaining it that's actually fixing it in a deeper sense so we've kind of and other people you you see this again with um uh project thinking we have a lot of project thinking in software which is unfortunate because software is mostly not done in projects it's products you see there's a real bias here we even see we even hear a project is a thing that has well- defined end State and you're done you know sort of speak to developers and yeah yeah been yeah this project has been going for you know six or seven years and it's just like wow that's as long as it took to put humans on the moon pretty much your project must be really late or really complex it's like no that's because it's not a project it's a product in software we've misused the term to the point I I still find myself referring to projects it's it's deep in my vocabulary deep in my vocal habits it is also in our environments open up an IDE you're offered the opportunity to create a new project that's CU if it were a new project when are you think you're going to be done with this yeah that would be a useful thing to have but I'm not not going to suggest that the point there is that that way of thinking about it is deeply flawed so the idea that we have with maintenance is that we've ended up with project thinking and then we've done the initial release and then it goes into maintenance which is actually you know dwarfed the original timeline of the project so called and what is maintenance it's either bug fixing or it's a thing we call software development it's where we add new features we already have a term for that okay so I want to re I'd like to reclaim I suspect I'm not going to be able to reclaim the word maintenance here so give I I do have a you know a lot of what we want to talk about here is actually about identifying and naming Concepts and I have um a copy of the Oxford English Dictionary on my laptop it's one of the few things that I actually installed that that doesn't just kind of like come from uh come from the internet every time I get a new laptop he's say no I've got physical Optical drives or or physical optical disc we only have one optical drive in the house every few years I have to hunt where is it and I install a number of dictionaries because I think dictionaries are fun I even have like real world paper kind of dictionaries I think dictionaries are fascinating um the AED is particularly fascinating because it is almost entirely useless as a usage dictionary if you want to find out the meaning of a word this dictionary is useless cuz it's an anal ological dictionary it you know it starts with the original meaning of the word and works forward the meaning you want is probably at the bottom you don't actually want to find out how it was used 800 years ago that's not how we use it anymore unless you want to find out how it was used 800 years ago yeah that's it's good for word NDS however it does give some fairly thorough definitions so let's talk about this idea that we are dealing with which is that we we frame and understand the world of software the world of insubstantial things through metaphors a metaphor is not just something that is poetic it's actually something deeper we're going to see that it's deeper figure of speech in which a name or descriptive term is transferred to some object different from but analogous to that which uh to which it is properly applicable and the key word here is transfer it literally means that uh in ancient Greek it is the idea of transfer we are going to try and say well you see this thing that's really kind of complex and difficult to understand Al that is novel or is abstract what I'm going to do is I'm going to create a mapping I'm going to say you know this thing yes you understand this thing yes I'm going to say by understanding this thing I'm going to give you points of Correspondence so you can understand this thing that you don't understand awesome so that is the basic idea of a metaphor why does it matter to us well um in uh a book I co-authored number of years ago um actually the Genesis of that but was in this building bizarrely enough um uh we talked out a number of things on patterns but this particular book was a more philosophical book and we we ended up talking about the nature of software the a physical and invisible domain of software is more about metaphor than matter we end up dealing with um every every one of our names sometimes we overuse a metaphor too many managers in your code base you might have too many managers in your company as well but that's the point is that a manager is a metaphor we sort of say well if I understand the thing in the real world then I understand here so if you have everything as managers then you should already know that's not a good thing okay you know it's it's kind of clear from the name I'm not saying you don't want managers it's just that when most of your code is managers and anemic domain objects that's a bit of a problem but the idea is we are using Concepts in the real world to describe things the very the very basis of everything that you do if I use the word network that's a metaphor if I talk about Windows that's a metaphor it's it's none of its real kickable stuff but we're describing it in terms of real kickable stuff so that's what you're ultimately dealing with and then we might you know abstract a bit further we might rise to the Dizzy Heights of assembler but normally we don't work at that level we kind of do stuff like this okay so this is smang and we add Concepts to it that are simply not present at all in the underlying ones and zeros we regard indentation as significant because we are visual creatures okay the we we use separation to apply significance and group things say I want I want to I want you the reader this is for you this is not for the hardware the hardware doesn't sit there going oh that's badly a line code I'm not running that I mean I think it would be fascinating um if we did have such an opinionated um uh style of Hardware but none of this has any bearing on what's going down at the lower level at all it's so disconnect it's a formal domain we have other ways of visualizing structure we have even con even conventions for how we talk about this stuff and when you draw layering do you draw layers from left to right or top to bottom or just kind of randomly across the Whiteboard well no kind of top to bottom we we even give we even give a sense of gravity to our software it has an up and a down we use our physical frame uh our physical framework to try and understand this abstract thing and we give it names we can talk about it structurally we can talk about it temporally we can talk about it in terms of of states and time and Transitions and we have a a rich vocabulary here we borrow words from The Real World we say this is this and it's just like there you go this is a bit where you get hungry snack of Pancakes M yummy the point there is that all of this is how we reason about the stuff down there but it also applies to our our processes and the activities we have around things this kind of interes in metaphors goes back I mean look at that cover I mean that's that's a beautiful I mean it's published in 1980 you got that kind of like just at the end of the 70s Vibe nobody would use you know would have a book cover like this anymore um and lovf and Johnson um metaphors we live by they really explored in depth how we as human beings use metaphors deeply within our language it's not just a matter of poetry the essence of metaphor is understand understanding experiencing one kind of thing in terms of another okay that's all good so let's evaluate what it takes for something to be a good metaphor occasionally people will sort of say things like oh you know that metaphor is not perfect you know we say okay let's talk about software architecture yeah the architecture metaphor is not perfect and they will use that as if that's a bad thing like well no there's no such thing as a perfect metaphor because if it were a perfect metaphor it wouldn't be a metaphor it would be the thing so by definition metaphor is an imperfect mapping and that's fine but we can grade them as to whether or not they're better or worse so I wrote this piece for O'Reilly radar a couple of years back because honestly what the hell were we doing a couple of years back you know um you know sitting at home staring at each other on screens um so you I might as well write some words and so I talked about technical debt and I evaluated what I felt you know what are the three kind of key ideas that make a metaphor good not good in an absolute sense we're going to see it's context sensitive to be considered good a metaphor has to offer a number of points of useful correspondence with what is being described if it has loads of you know if it doesn't offer these points of Correspondence then it's well yeah it it's not helpful okay so that's the primary one we normally look at because well I want to say you understand this feature this set of Concepts or words these can be found over here in the thing we're trying to describe great another quality is that it should not have too many obvious points of conflict that's the tricky one because there will be conflict that's not a choice you will you will have differences between the metaphor and the thing you're trying to describe that's fine but they should not be egregious and awkward you should not spend your whole time apologizing for the metaphor okay and working around I mean I know as software developers we're very good at working around things but you don't want to work around your metaphors too much and then this one which is the really context sensitive one third quality of a metaphor that makes it effective is familiarity to its audience and this is really important because you might have the best metaphor in your head and then you offer it to other people and they have no idea what you're talking about because what you're trying to do is you're trying to explain something in terms well basically let's put it this way here's a thing you don't understand and I'm going to explain it in terms of this if you don't understand this either then I have to explain the thing that I was going to help you under no this gets messy too many levels of indirection okay so let's actually have quite this this is a good one this thought from Chris matz it was written up by um Steve Freeman a number of years ago you can find the uh Steve's blog piece on this uh by using the way back um machine so um but the observation bad code isn't technical there it's an unhedged call option okay who here knows what an UNH call option is okay so a few of you do for you I mean I'll take the observation here for people in fintech this is a really interesting analogy for people outside it it is not only I mean I think it qualifies as almost entirely useless here this thing that you understand or this thing that you have some understanding of I'm going to explain it in terms of something you have no idea of and I explain the derivatives Market which is a glorious work of fiction that apparently is worth quadrillions of dollars which is actually more than the more than if you converted Earth into its basic materials pretty much it's just like no this is this is a Dar idea it's betting on a bet but that's just me talking about fintech um but the point is if you are in this space then you might go oh yeah yeah I see that that works light bulb moment but if you're outside it so therefore the goodness of a metaphor will depend to some degree on on the audience now often we favor metaphors that can be shared broadly okay um even if we don't understand them perfectly I've mentioned software architecture earlier on um I think everybody thinks they know what an architect does and what they actually do is quite fascinatingly different to what we think they do uh and they understand Building architecture why because we live in buildings so therefore we understand them right yeah it's a my wife used to be a um primary school teacher and uh she said one of the biggest problems that she had was parents who knew about schools why because they had been to one it turns out that when you are 6 years old your experience and knowledge of a school is quite different to when you are 36 okay it turns out that knowledge is not transferable across 30 years it doesn't have the same meaning no you have no idea so we often have a very naive understanding but we do try and work with metaphors that have broad appeal when people talk about software and Engineering they normally appeal to civil engineering for the same thing we understand what bridges are and so on people often don't talk about chemical process engineering because only chemical process Engineers would know what they do but it turns out software probably has more points of correspondence with chemical process engineering than um civil engineering so that we have this notion of this mapping so let's go back to the dictionary let's look at this other word that I've been using Legacy so Legacies interesting um Legacy is interesting because it normally has a positive meaning uh in English we normally regard you use the term Legacy favorably and positively someone's Legacy um we only describe Legacy as a Bad Thing by adding another word to it by default Legacy means good if we say you know a bad Legacy or a poor Legacy then we've qualified it as negative but on its own it has a default positive meaning in software we have taken a good idea and yeah messed it up but we only did this well I mean it depends so 1989 for some of you this is before you were born and you're thinking well that's that's obviously an ancient concept and Timeless because it existed before I existed so therefore it is old for those of us who were around in 1989 we might be surprised at how young this vocabulary was you know what what did people call it before then did they just Express frustration without words so um and we have a definition which is it's not bad it's kind of adequate um designating software or Hardware which although outdated um or limiting is an integral part of a computer system and difficult to replace so actually that's not a bad definition but Legacy does not have one unique defined meaning I actually run workshops on this as I said and and part of my um software architecture uh courses I do often run a section where I ask people what do you mean by this because often we will find different people mean you know oh I'm working on a legacy system has a different meaning in different part of the organization and you sometimes for some developers Legacy code is well code that I didn't write um at other times it describes something that is a um you know it's a money sync it's it's a it's a you it's costly and difficult at other times we're actually describing something that is outdated and actually there's a problem there of lack of knowledge the knowledge of the what makes the system Legacy is the knowledge walked out of the door years ago we don't have any any body here who's still working on it we Define legacy as the absence of knowledge and capability in other cases we're dealing with well you know yes we still have systems running on Windows XP even though Windows XP was retired forly 10 years ago um and we're describing those things and we we're describing the difficulty of getting people working on it so there's lots of different ways we approach the term Legacy and I'd like to look at it in terms of other consequences so this was post I saw a few weeks back um uh Angel sandon C described Legacy code is often defined as code that makes more design decisions than the team working on it I thought that's a really good way of looking at it I think that's a really you know it's just like you know so right we're going to have a design meeting who's turning up well there's me uh there's a couple of senior developers we've got four or five Junior developers then we've got the codebase high code base did you get a coffee for yourself you good okay and it turns out uh you know there's the rest of us making decisions in the code Bas is sit and they go nope nope we're not going to do that oh no that's that's not that's not something you can do with me I'm afraid I have a veto on this oh you want to be agile have you seen me no it's just like it's not going to happen the code base actually has the casting vote the codebase is making the decisions and everybody else is like a puppet okay and actually Angel goes on to say could we Define a legacy process as one that makes more decisions on how a team functions than the team itself that's about the culture and the tools but also shaped by the very software that we're dealing with so that's kind of an interesting way of thinking about it but we are certainly seeing what we're learning is whichever way we look at it Legacy tells you how you're going to spend your time in fact that's one of the definitions of architecture that I tend to uh favor is that your software architecture tells you where you're going to spend your time and that may be a good thing or a bad thing yeah but it tells you where you're going to spend your time so I stumbled across this uh article um I think was probably last year um over a trillion US dollars to keep the lights on legacies drag on productivity woo this is big numbers okay 2019 US Government accountability office um report found that the federal government spends more than a hundred billion dollars on it and cyber related Investments annually okay big numbers of this amount a agencies have typically spent about 80% on the Ops and maintenance of existing it Investments including Legacy systems that's pretty hefty amount pretty hefty proportion of existing stuff not new stuff existing stuff so let let's look more broadly so on average if we we move outside um the US government on average 31% of an organization's technology is made up of Legacy systems and you might initially think oh that's not too bad it's less than a third just remember that that 2/3 is waiting in the wings to become that you know move into that but remember quantity by proportion is not everything it's not the 31% that you have to worry about is how much are we spending on that 31% oh that's quite different maintaining those systems that's a disproportionate amount maintaining those systems can be a costly burden with an average of 60 to 80% of it budgets allocated to keep them running woof that is yeah okay that's that's kind of different of course we focus on new stuff and find most of the sessions that you may have been to focus on the new stuff Legacy Technologies hamper efficiencies and restrict growth in an estimated 88% of businesses you know I don't even care if this estimate is I mean 88% is two significant figures that feels surprisingly I'm not quite sure you you can quote it to that um based on the variety of the industry but honestly even if if it's 50% wrong it's it's it's still a massive amount it's just like wow Legacy is a constant drag force on development so in this splendidly titled paper by Adam torill Marcus Bor and Andis Ms uh in fact Adam torill May he's done some really really good work I mean a lot of code analytics stuff um you may has anyone come across the book your your code is a crime scene so he's that second edition's out in in print I am biased I wrote the forward uh but the reason I wrote the for is because I think the book is so good the whole idea of if you want to answer half the questions that you have of your system go and ask the system yeah invite it to the meeting it turns out it has a lot of history that is one of the good things about a legacy system is it has history we the thing we're not very good at is learning from history you you can actually go and find out from the code base what are our hotpots of change what are the areas of avoidance what are the parts that people touch and who owns what what things get changed together there's a lot we can actually ask what are the trends in the codebase look at the trends but they they thought right okay you know let's let's find out a bit more you know AI it's it's a Thing refactoring versus refactoring advancing the state of AI automated code improvements we might think okay Legacy we have a way out we are going to use AI sprinkle pixie dust we introduce a novel Innovation which is this is one of the interesting things so I'm actually putting one of the conclusions here first we introduced novel Innovation for factchecking the AI output and augmenting the proposed refactorings with a confidence level by rejecting incorrect Solutions 98% of the remaining AI generated refactorings improve the code while retaining the original Behavior now what is important to understand here is what they're saying is the raw output from an nlm is not sufficient you need to do fact checking just like you do with anything else you know every time I've I've I've asked chat P anything it's just like yeah but I happen to know the facts on this one and that's kind of a little bit wrong there but you know uh but you're delivering it with kind of like sociopathic confidence um uh you know you need to approach these things with a bit of skepticism and the point here is that what they've done is they've added fact checking what happens when you don't have the fact checking so you know by definition a refactoring is something that doesn't break something yeah hey I've just done this awesome refactoring the code doesn't compile no small detail it's so awes what happens if you just leave you know if you use an out-of the Box llm Hit or Miss situation oh how Hit or Miss in fact the best performing model only giving a 37% probability of success that's absolutely shockingly bad I mean you know if your success rate with refactoring was this low it's just like wow that's pretty bad if a developer had this success rate you would really kind of going have little conversation with him is everything okay I mean are you good I mean do you need some time off um do maybe a different industry like not software you there's there's you know that's a really bad number so out of the box this is not good stuff so no that the path is not going to be given to us by this and we'll also see some other interesting consequences of this because we also have to go back to the fact that the boat is taking on water okay part of the thing is not fixing the stuff that comes out is actually the creation Legacy code so this is the bit where I predicted the future but it turned out to arrive a little bit sooner this was April last year so I posted this on on on masteron practical consequen of using llms to generate code is that many developers will find they've unwittingly moved themselves into a role they were probably trying to avoid they have automated the creation of Legacy code because who wrote it well somebody else it wasn't me but yeah I took the fun bit of my job and now I'm left with because I have to fix it and understand it I've actually made my job worse they've redefined their job as debugging and fixing such code now I'm not saying this is all bad I'm not going to be what I'm saying is that this is like any tool situation what we have learned is that a lot of people put you know oh here's a people problem let's solve it with technology or tools and it's just like no no be I actually did a talk NDC London last year where I was talking about refactoring and the fact that you know I I I sometimes joke you know here in the 2020s I think it's so great that nobody has to deal with you know long methods that have their own kind of event Horizons that people don't have to deal with incoherent messy classes and like dependencies that you know that uh just have just this tangle to them that you will never disentangle I think it's great that people don't have to look at code that is meaningless and ugly and difficult to change because you know what you know what happened 20 years ago about 20 years ago is when automated refactoring started becoming normal we solved the problem 20 years ago 90% of the problems people experience on a daily basis were solved over two decades ago and then you kind of think oh right so it wasn't the tool was it we've got the tools is to do with our skills and um our environment our situation turns out it wasn't a tool problem turns out it's not a tool problem so here's where I got proven kind of right somebody somebody sent me uh an email just the beginning of this week oh kevn here's the study coding on co-pilot and this was done obviously I'm going to say that there needs to be more followup research on this but the folks at G CLE had a look 2023 data shows downward pressure on code quality already I mean if if co-pilot were a human a human child it wouldn't have even gone to school in fact it would probably be toddling around asking for another biscuit or something with barely a grasp of language and a barely an understanding of gravity 150 million lines of analyzed codes projections for 2004 not good this is the current Trend in terms of code churn so we find disconcerting trends for maintainability already this is the bit that gets me I was kind of thinking oh yeah you know I'll be talking about this in the late 2020s no no no it's already happened it's like coacher the percentage so they had a definition percentage of lines that are reverted or updated less than two weeks after being uh authored is rejected to double in 2024 compared to uh 2021 prei Baseline that's that's pretty bad so what's interesting here we you know they they went further we further find the percentage of added code copy pasted code is increasing in proportion to updated deleted and moved code there's all these people who keep joking about well you shouldn't use copy and paste it's just like no let me let me use AI instead because it's copy and paste via an indirect route yeah but actually that's the problem is what's happening is people aren't perceiving their structure they're solving a problem in the situation because that's where they're focused I'm not going to blame people for being people because you're focused on it but the problem is unless you know that this comes with a tool you see this this kind of tool is Inc is going to have a huge impact for people who know how to use it just as refactoring tools when you see somebody really understand the concept of refactoring and the tooling they have when you see them work you go oh okay there's a real difference between what you're doing with that tool and what the majority of people are doing with that tool and I think that's the same case here the people who know how to use this and understand its limits but also understand how to get its advantages are be way ahead of the rest of us who are going to be busy slowing down in this regard code generated during 2023 more resembles an itinerant contributor prone to violate the drus don't repeat yourself of the repost visited so itinerate contributor the point that they were making in fact the question they were trying to answer is if we use AI assist do we end up with code that tends towards the skills of a senior developer Who belongs to that organization and has experience and history and a vested interest in that organization or do we end up with code that reflects perhaps the style of a short-term contractor we have the answer it reflects the style of a short-term contractor it's like again I'm not going to you know short-term contractors no problem with that it's just you need to understand what you're getting and what the incentives are it's not even just a matter of skill sometimes we can have our skill nudged in the wrong way by the wrong incentive model but here we've automated that problem we've made it potentially worse so no this is not the way out um the way out is first of all we need to start rethinking about this so let's go back to the kind of territory of metaphors Legacy code that's one way we try and talk about it we also talk about things in terms of spaghetti code a term from the 1960s and 1970s which is referring to control flow it's not really a metaphor because I mean I mean I like spaghetti you know you know it's just you know it is my favorite pastor and it's just like you know you're describing this code in those terms you're trying to draw a visual parallel but it's not truly a metaphor in that sense I'm not using it as a means of understanding and then people try and then swi there's a kind of old code switch they do to the metaphor of lasagna oh you don't want spaghetti you want lasagna cuz it's layer it's like actually I prefer spaghetti to lasagna lasagna is not necessarily good or better you know but and then what I love is each generation rediscovers the meaning of ravioli when I first heard that in the 1990s son said ah you want ravioli code object orientation and then as the '90s wore on it became components and then it became services and these days it's microservices which bizarrely are larger than services this word micro I don't think it means what you think it means okay but the point there is each generation each hype cycle somebody rediscovers these things but it's not really a metaphor and I don't think it's a very helpful way of describing things then we move into stuff that starts describing physical processes code Rock software Decay now these are quite nice because built into them these move us in the right direction because built into them there's a concept of time there is a progression of time and a degradation over time yes that's what what we're talking about the only problem with these really is that they they require a kind of natural process and that's not really happening in in software you know it's it's if you leave that yogurt in the fridge for a few months we can rightfully call it an experiment in biology you didn't have to do anything it just became that way okay there are natural processes working on it that are separate from you which is not really what's going on with the code sometimes you can get a a situation where it's almost a relief to find that nobody's changed a file in 5 years because at least you know it won't have got any worse you know if you happen to know the if you happen to know oh yeah there was a big merger four years ago and everything went to you can see at least say well you know five years this code hasn't been changed in five years then you know that's probably better than some of the other things that are going on we have stasis by default so these are getting towards a good metaphor but that that that notion of natural agency doesn't quite get there but it does suggest maintenance uh entropy I always liked entropy as a way of describing it um company I I worked at First company after University we use the term entropy technical debt hadn't been invented as a term at that point we use the term entropy or a number of us used the term entropy and that's because we all had degrees in physics and for us this is like yeah this makes a lot of sense the problem is that it turns out that that's not necessarily common knowledge and you end up with the explanation let me explain the second law of thermodynamic your audience their eyes have glazed over you're trying to explain a thing that's hard in terms of another thing they don't understand it's just like no this is not going to work out well technical dep the one that we are familiar with unhedged call option one that we may make more sense to fintech crowd and say the physics crowd well actually there's a bit of an overlap there uh housework I love this one we'll come back to this one in a minute so the popularity of this term Tech de is a wonderful metaphor developed by Ward Cunningham this is Martin Fowler writing in the early 2000s he's unfortunately he's since updated this blog post I wish he kind of kept it because it's quite historically it's quite well of course you can use the web archive to go and find the original because for me it's quite a historically important one because it helped popularize the concept after 2003 the term became much more popular um so Ward Cunningham if you're not sure who Ward Cunningham is he's the guy who invented the wiki he also came up with Cunningham's law if you don't know what Cunningham's law is you do know what Cunningham's law is you just probably didn't have a name for it um it is uh the observation that if you want to get a correct the correct answer on the internet post the wrong answer yeah if you just ask a question it won't get answered but if you if you post the wrong answer boy people are happy to correct you um in this metaphor doing things in the quick and dirty way sets us up with a technical debt which is similar to a financial debt notice he's saying which is similar it's a metaphor it's not the same but we do have a slight problem is that I'm not going to blame Martin for this solely he uses the term quick and dirty here which has negative connotations it's a US English term okay and basically it's it suggests expediency but it it suggests you know kind of like yeah it's a bit of a screw up you know It's Kind yeah it's not it's not perfect it's a hack it's a workaround it's a clu it's a whatever it's got a certain Badness if you like built into the term the problem is that we pick up on these things and most people's experience of debt is inherently negative um the debt crisis and things like that so yeah we have all of that so it's worth looking at what Ward actually wrote back in 1992 and what is interesting is that he introduced the debt he did not use the term technical debt in the 1990s people variously use different terms technical debt design debt quality debt I generally prefer Technic sorry design and quality debt when I talked about stuff technical debt kind of became sealed as the term in the 2000s and particularly as it took off and became a standard piece of vocabulary in in our kind of discussion of software architecture but what Ward says may surprise some people shipping first-time Cod is like going into debt a little debt speeds development so long as it's paid back promptly with a rewrite what he's talking about here is a considered tradeoff he's talking about in fact really it's not a debt metaphor if we look at it very carefully it's a borrowing metaphor I need to do a thing now but we don't have the time or the knowledge and sometimes we just okay this is new this is a new piece of the teex stack how do we do the perfect job we don't know yet but well I'll tell you what let's just try this and see what happens and then we kind of come back with our knowledge we do that and we know that it's not the perfect way it's the one that it's the one that looks like the examples in the blogs it's a bit copy and paste it's a bit kind of put together it's a bit based on our previous preconceptions of how we've worked with other Frameworks or or pieces of code that are like that and we know that it's not going to be perfect and that's fine that's great sometimes we're doing this because of reasons of time that to do the full job is going to take a lot longer but we'd like to have something out in the field and then we'll see what the feedback is as to whether or not we spend more time the whole idea is that it's a considered tradeoff between two points of time I don't have the money this month but there's a thing that will be only available this month therefore I will use money from next month notice the borrowing metaphor the money from next month I know where it comes from to do something now that was the whole point Ward had a positive view of this he was using debt in its kind of you know more formal um sense the way an economist might look at it favorably the danger occurs when the debt is not repaid he in other words that wasn't the point he's just saying oh by the way this bad stuff as well of course you were not going to do this of course you wouldn't god wow every minute spent on not quite right Cod canel's interest on that debt hence the basis of the metaphor the idea of the interest the extra work you have to do on it the fact that people are going to start working around it the fact that that's going to become your architecture if you're not careful yeah oh yeah this is just a workaround two years later this is our architecture yeah so that observation um although we know by definition no metaphor is perfect there are two common ways in which the metaphor is misapplied one is assuming that it's necessarily bad not all debt is necessarily bad okay if you if you've um sometimes it can be a bit of a a drag but on the other hand you know if you've got a mortgage which I always love the fact that the word mortgage contains the word death in it you know there kind of a clue there as what it's going to feel like but it's an intentional tradeoff it's structured it's a structured repayment you have some control over it what are you getting in return you're getting a house oh okay that's not a bad deal fair enough because you can't afford a house otherwise unless you're extremely fortunate but the idea is like yeah I can't afford a house today but over a period of decades I can cumulatively afford a house so therefore I'm able to achieve a benefit I otherwise would not this is the positive idea here okay and we have a management model for it we have a repayment model that's what most people are missing is that it's they're not using the borrowing metaphor they're using the kind of like yeah we're just running up a debt and you know crossing our fingers uh kind of approach whereas it's actually borrowing you're borrowing from your future time your future opportunities that's where that kind of 60 to 80% of the drag on on U uh uh uh on opportunities is coming from or the 88% drag sorry 60 80% of cost equating technical debt with a financial debt value this is a mistake and sometimes people push the the point of a at this point it's not a case of we it's not a case that the metaphor we have to recognize the metaphor is intentionally incomplete and imperfect unifying it with financial debt is an incredibly bad idea because it gives you a gives you a a kind of a false sense of reality and it's based on incredibly bad science there are also tools that will automate this bad science for you they will look at your code and they will say this is how much technical debt you have in your code base in pounds euros dollars Etc and the technical term for this technique is  I, mean, if, you, need, me, to, break that down for you this is bad science on a staggering scale please never I I've had people s yeah yeah but we we use that number that's generated by product that I'm not going to mention now now we use that number because it allows us to talk to management and I said yes but if but I said this now becomes a moral question you know it's that means you know you're lying yeah that I leave that to you as to what you want to do with that fact but the problem is why is this if I've got a piece of duplicated code and we generally agree that going around copying and pasting everything is not generally a good idea but can I look at one piece of copy and pasted code and say ah the cost of this this across the whole codebase is this amount because it turns out that well no you can't because you need to know context sometimes there are little Parts where duplication will benefit and they it will allow you decoupling so I cannot say that per you know there's a constant cost per thousand copied lines that will you will incur you can't do that because you actually go oh yes this apparent duplication decouples these two systems and saved us a lot of time yeah um had this situation with a company a few years ago where they had accidentally tried to do a reuse program although they intentionally tried to do it and the reasons people do this is because they want to achieve a benefit typically in time and quality what they discovered is that they ended up coupling two otherwise independent teams together and they slowed them both down rather than and it was a case of like right how much logic is actually duplicated 5% you know that's a fair cost yeah pay pay your 5% dup duplication and the minute they did it's like oh we're all back on schedule so the point there is you cannot do this with the code base in any any any sense it's automated so again we returned to this thing about the effect and understanding the cause and the notion of technical debt but what's really going on when people are talking about technical debt primarily is unmanaged technical debt there's a word missing people say oh we have a technical debt problem perhaps they do but not in that phrase it's an unmanaged technical that minute we put the word unmanage there it makes it invites the question of why are we not managing it because it's the manage stuff you know if if a team said oh yeah we've got we got yeah we got a whole loot of technical debt you know uh and this is how we deal with it we put stuff in jera we write adrs we devote a certain portion of every Sprint to dealing with it and all the rest of it it's just like well you don't have a technical debt problem you're managing it perfectly well you've got a sensible repayment model that's not a problem you might have a lot of technical debt but you seem to be doing the right things with it the problem that we have is the unmanaged stuff where does it come from and where does it go I feel like coton n but no so um the cotton n Jo Paradigm so the point here is that's the real problem the unmanage stuff how did it come to be and what are we going to do with it yeah this is the hole in the boat okay this is this is we need to address the fact there is water and that we are taking on water that's the question we need to be asking um Martin Fowler also had a way of looking at this um called the technical deck quadrant he used a slightly different language um uh he talks about um Reckless versus prudent debt and intentional um know deliberate debt um and accidental debt uh I tend to use slightly different words um because these ones help you focus um and you know if I say unmanaged this immediately implies this are managed and the question is okay and I'm also not making a moral judgment here whereas when you use the term Reckless there's a strong moral judgment in that in in that phrase so the for me I I'm interested in this and what are the consequences of this well what do we have if you do this you will have staff retention problems you'll have security potential security problems because if you're saying we have unman technical debt you're basically saying who knows what our code is like we don't have full knowledge of it or full control of it or by the way yes we do believe in security well no you just told me you didn't you can't both believe in security and say honestly we have no idea what's going on in our code base security is is a is a kind of like a multivariable thing and being able to control your codebase and your dependencies is part of that story if you don't know what's going on there then you are vulnerable and if you say oh yeah our codebase is totally vulnerable but we're secure those two phrases don't inhabit the same universe compliance def everything just becomes harder so that's the message of the technical debt metaphor it's not simply a measure of the specific work needed to repay the debt it's the additional time and effort added to the past present and future if we don't address it that comes from having the debt in the first place if you want to go back to fintech this is a this is a complex Financial instrument and we don't know the future the idea is that it's about how we resp respond to it and if we're going to talk about response then here's Ivon Lamb's observation my theory of tech debt is that housework is the correct metaphor for the thing we call Tech de but we can't use it because Tech has been made up of people who don't do housework or manage housework being done spot on well done remember it's to do with familiarity yeah is it familiar to the audience yeah and I'm going to say that for a lot of people housework that's that's what Douglas Adams called an SEP somebody else's problem So speaking of housework uh this is Isabella Beaton she um Victorian figure uh she died when she was only about 30 she was a contemporary of people like if I remember correctly if I've got my timelines right contemporary of aah love L and Charles Babbage but she gave us the best wisdom on software development without caring about calculating engines of any kind she wrote a book on household management that has actually survived into the actually survived into the 20th century um and she gave us the advice let's go back to the mess I'm making in the kitchen there is no work like early work clear as you go mule makes more model wow it's just like the wisdom software development wisdom encoded in a book of household management very clever that's cryptography for you not to wash plates and dishes soon after using makes more work the advice is there this is what modern commercial kitchens run by it is the very simple observation that you know we're going to talk about the debt we're going to talk about debt and interest the amount of effort with respect to time if you do nothing else it rises exponentially and because that means you are doing all you're having to work around or deal with all the stuff that you have accumulated so far we can go for a punctuated approach okay a punctuated approach is very much okay we'll devote a certain amount of time and a certain number of people at particular points in time to kind of let let's go through and just have a bit of a discussion bit of a meeting let's go and find out what's the dead code what are the bit the areas of high code shown we should be worried about um you know do we have any adrs that look like they need revisiting do we have any other comments and things in jir that we need to let's let's actually do this and have a kind of like a a regular kind of cleanup and that kind of drops this it amortizes it and then because everything is continuous these days we recognize continuous everything implies well do it clear as you go the idea is that there's not a separate piece of time that you're going to allocate to this because I'm going to recognize that maintenance is in this sense ongoing one of the things about software is that it is not physical it is a it is a thing that we can do at any point in time it's not doesn't have logistical barriers the way that many things in the real world do so we are in a position where yeah if that's of our workflow yeah it's we we don't we don't mark it out as separate so yeah let's close with this thought that maintenance is a is an action but what we're really worried about is inaction it's the problem is the absence of something this a very very interesting model John Sedin um who's not a software guy he's a systems guy broke this down very nicely um demand so economic terms here Supply and what is the demand for my work if I sitting here at the keyboard why what is the thing that I am doing what causes me to do this am I adding a feature that somebody has requested and will be of benefit to them value demand represents the demands customers make for the things they want things that are of value to them or am I dealing with failure demand failure demand is created by the organization not working properly more specifically failure demand is demand caused by a failure to do something or do something right how much of our work comes from something not being right or not being done right there's always going to be some amount by the way zero is not we're not aiming for zero we're just aiming for Less obviously fixing a bug is an example of failure demand but so is sitting in front of something going I have no idea what this does and the last person who did left 5 years ago yeah that's that is you know coming up with genius ways to work around things yeah this is failure demand and if we're talking about the thing about you know in action then that's the word neglect want of attention to what ought to be done the fact of leaving something undone or unattended to negligence if we look at actually how much this is quoted in um Adam and colleagues paper from another paper published by the i e if I remember correctly you there there you can find various different versions of this lying around how much of a developer's time is spent on actually writing and editing code notice where our tools are targeted that little 5% there yeah don't lose that 5% it's fun understanding so it turns out you know I and I did this in estimate utterly informally there's no science behind this at one organization a few years ago I estimated that I sort of said I remember saying to the department head I said you know in an 8 hour day your developers are lucky if they're actually spending an hour dealing with the future they're spending seven hours fighting the past and that's on a good day okay most of the time they are dealing with the consequences of exactly that neglect we have let something go and now we have a problem with it but we don't have the language or the framework the way to approach it so let's end on that thought that a lot of these things are about increasing our awareness is to see the thing that we're not seeing to notice the absence in our habits or our culture for supporting something to understand what the tools do and do not give us and how we can integrate that into a flow so you literally don't have to think about it that's the point habits are things you don't have to think about we want to integrate this to recognize that all those little actions can accumulate something better when we look at the overall cost of negligence these are not this let's let's understand that codebases don't become messy Legacy and all the negative stuff they don't come that typically through willful actions you know it's not anybody being malevolent going like okay today I'm going to go in and work and be super evil like this is not some kind of trivial Bond movie you know but play that in software architecture and it's also not mostly it's not deliberate you don't sit around in meetings going like okay let's um let's talk about uh let's talk about the code we're going to write anybody got any suggestions for how we should go about writing it oh no tests I think we should absolutely abandon tests uh that's a great suggestion um and any other suggestions yeah I think our methods should be at least 1,000 lines long um preferably longer that's an excellent suggestion yeah evil cackle you know that's not how it's done this stuff happens not through any kind of willful action not through malevolence it's not even people being stupid or evil or or lacking even not even lacking certain skills many of us know what the right thing looks like but sometimes we find ourself in a situation where we're taken away from focusing on that but we need to have that bigger View and understand that we're not working on projects we're working on products products last years that there is there are consequences and that your habits start right now how we spend our days is of course how we spend our lives thank you very much [Applause] right so the good news is by overrunning a few minutes thank you for your time by overrunning for a few minutes I've I've made sure that you avoid the initial rush for food how about that uh but yeah if you have any questions please come up