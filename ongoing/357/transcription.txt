Welcome to the modern software engineering channel. I'm here today with Emily Bash and we're going to talk about one big question. And today's question is, should test-driven development be more widely used? Emily, should test-driven development be more widely used? >> Yes,, I, think, it, should. >> I, agree., I, think, it, should, as, well., So, are we done? I think we've got more to say. >> Definitely., So,, let's, talk, about, what TDD actually is. um because there are a lot of misconceptions and people who argue against TDD from a basis of describing something that isn't TDD. So I think that's uh the first thing to establish what we mean by that. And I think um I want to talk about uh Kemp Beck's canon TDD. He's got a post about this. You know that basically TDD involves first thinking about the problem you're going to solve and writing a test list, breaking the problem into small pieces and each of the items on that list ultimately is probably going to turn into a test case. And you do them one at a time. You write the test. You get it to see it fail. It's got an assertion in that test. You um write just enough code to make that test pass, which and that while you're doing that, you can commit any design sins that you like. You know, you can duplicate code or just write everything in one function or whatever. And then you have the refactor step. Once the tests are green and passing, all of the tests should now be passing. Then you refactor. And then you go back to your test list and you pick another test off the list. And of course while you're doing this at any any point you can add tests to the list or you can cross tests off so that that list is is dynamic and and gets updated. And the idea of this is that you always are working in the context of either all the tests are passing or you've got one failing test and uh you always know which of those states you're in. And at the end when you've run out of tests on your list you've got a good regression suite covering the functionality that you've just built. Uh so I think that's really what we mean when we talk about TDD. I I I I think that's I think it's important to get that kind of nice statement of what it is that we're talking about in place. And the other thing that I think is important is that one of the critiques that I've heard of test-driven development is that it stops you being able to design. And I think nothing could be further from the truth. part of your description. I think that there are two key focuses on design just in that short description that you've just made. At the point at which we're writing a test, we are consciously really designing the external view of our code from the perspective of a consumer of our code to be nice to be easy to interact with. So, we're designing the the interface to the code that we're about to write is really what we're doing when we're writing a test. And then we implement the code. We're not really designing there. We're just trying to be tactical and just get something working in place quickly and efficiently so that we minimize the distance of insecurity when we're we we've got a failing test. So we're going to quickly get to a passing test. And then the next stage of design is really the refactoring where now we're designing the internal implementation while we've got a passing test that tells us that everything that we're doing is still working. So I think that it's this enormously powerful tool that drives us to design better code from the outside because we bu we build better factored code because it must be in order to be testable and it gives us a more stable platform for coming up with better implementation detail because we we know that it works because it passes all of our tests. So I I I really like your description as a starting point to get us going. That sense of design is a huge part of the value of test-driven development to me. >> Yeah,, absolutely., I, mean,, it's, got, these these two great outcomes from it is I mean the tests themselves, the regression tests that should help you to understand, but but as tests go, unit tests often don't really prove very much. I think there's a lot of testers out there in particular who'd be like you can't judge the quality of a product purely on the unit tests. I mean there's there's got to be more testing involved to to actually show that the thing works, but it's a very good start because it shows that the code does what you think it should do. And then the other outcome of TDD that is so important as you say is that the effect it has on your design because you're there's this Michael Feathers talks about this deep relationship between testability and good design. >> Um, and, it, it's, kind, of, flows, from, the fact that you've got you you're thinking about the client all the time. You're you're using the code uh in the test. >> Yeah. You have to be pretty stupid to write a design code that's hard to test because you're right. You're starting by writing a test. So you've got this automatic pressure on you. One has this automatic pressure on oneself to design code that's easier to test because otherwise we're stupid. And and so it gives us this, this this, this, forcing, function that drives us to to prefer testable code. And testable code is to my mind by pretty much by definition better code. It's higher quality code. It's more modular. It's more cohesive. Better separation of concerns, better lines of abstraction, looser coupling, all of those things. Because without those things, without any one of those things it's not quite as testable as it would otherwise be. >> Yeah., And, and, it's, a, skilled, activity and it takes a little while to learn it uh to to actually work this way. And a lot of pe so maybe we should talk about some of those objections that people have basically about you know and it it one of them I think basically stems from people not being good enough at design to separate their concerns in the in the way that you need to in order to make the, code, testable., I, don't, know how, to teach design other than to teach people TDD. I guess the other thing people say is that they uh they don't know how to test it until they've seen the implementation. They they can't they can't imagine the shape of the code until they've actually written it. And um that's always one that I've kind of most until till uh I had an experience just a few weeks ago that that made me think about that again actually because it's it's kind of true that you want to write the test as the uh as the user of the code and for that you don't need to know the implementation of it. You just need to know the interface that it should have. But I was I was coding with a group a few weeks ago and we were doing TDD and I didn't know their code base very well. I was coming into coach and they didn't know TDD very well. So it was we were kind of uh I was trying to help them with the TV TDD. They were obviously experts in their code and and we needed to implement a feature and one of the outcomes that was important that was when we adjusted the state of this domain object a message should appear on a Q somewhere else to say that this change had happened. So I was like okay well the externally observable thing here is that we have a queue with a message on it. So let's write a test that checks that that message is there on that queue. And we were getting into like what format of the message, what kind of object is it? What can we create a test double for the queue? And the test was getting quite difficult. And then we we we we got the test done and then we went to look at how to implement it and realized that there was a whole section of code that I was I had no idea about that was was going to do the message creation and putting it on the queue and all our bit of code needed to do was just like call a function with a few arguments. we've done all this vast setup and if I'd actually spent some time to really look at the implementation and think about how to do it, there was a much easier way to test it and drive that. >> Yeah, >> you, do, need, to, understand, that, the, the context that you're writing tests in. I guess I >> I, I, think, you, do., So,, so, I, I, was, I, was not one of the inventors of or the the the initiators of behavior-driven development, but I was there at the start and I was talking to the people that were coming up with the ideas and was involved in writing about it at the start. And it started out very differently to where it's largely interpreted now. It started out as a better way to teach test-driven development kind of for that reason. So to my mind anyway. So I think this is important because as you said TDD is kind of a broad spectrum and mostly when we talk about TDD I think we're talking about fine grained unit test level development but I think it goes further than that and there are more parts to it than that different types of tests that fall under the TDD cannon really. Um but certainly at that fine grain level but also everywhere else, what we really want from those tests is we like tests that express what we'd like the code to do without saying anything at all about how we achieve that. So that we've now got the freedom to determine how we're going to achieve it. So we can do that separately from specifying what we wanted to do. And by focusing on our our tests on getting the the behavior right it allows us to think about those two separate parts of the problem of writing software. What is it that I want to achieve? I can write a test that says that and then how am I going to achieve it? I can worry about the detail of how that's going to be achieved. And it's only in the second one of those where you really care about the implementation detail that what you wanted to achieve should be expressed by the outside picture. And in your case, in your example, you wanted to generate an event of some kind or call a function of some kind that resulted in a message. You weren't really the test doesn't need to know about that. All it needed was the fact that as a result, some signal was sent that that that would eventually result in a message. And that kind of leads, as you were describing before one of the things that goes through my head when I think about test room development is it's kind of analogous to the fine grain TED is kind of analogous to the the rules of algebra. If you're solving a problem in maths and you're using algebra as a tool, you need to follow the rules of algebra. You need to do the right things to expand brackets or to move variables around in in in the in an expression and all of those kinds of things. But that's not the only game. There's the higher level picture of whether you're actually solving the problem. So there's the kind of the mechanism which is the kind of fine ground TDD that we're talking about with unit testing. So you know one of the rules is that I'm going to given some system in a certain state when I act on it in c some way some result occurs. So how do I measure that result? What's the closest I can get to the piece of code that I'm writing now that's going to tell me that result? So that's what one of my rules of algebra for TDD and then you know you got put this in the broader context of does it plug into the messaging system that you know actually formats the message and sends it and all those kinds of things and I I I think it's one of the reasons why I talk about it so much about engineering. I'm talking too much now, but it's one of the reasons why I talk about this as engineering because I think it, as we've already described, it drives us to doing a better job when we start to follow these reasons. And I think that's deeply one of the reasons why I think TDD should be more widely used than it is. >> Yeah,, you, said, a, lot, there., Yeah, >> sorry. >> But, no,, but, this, thing, about, um, TDD making you focus on the the uh the spec the observable outcomes. What should the system do? That is absolutely what I was trying to do. I guess I I was just kicking myself afterwards that I'd missed that actually I could have written a much smaller simpler test for this bit in this situation and that would have been uh more useful for driving the design just cuz I didn't know the code and I didn't know all this existing code was there and and actually they didn't either. It was an area of the code and and if we just spent some time looking so I think this is why people want to to know the shape of the implementation before they write the test because then they'll they'll maybe find an easier way to test it. But like you say that then maybe we'd miss the the whole the aspect of specifying it. >> I, must, confess, I, don't, know, if, it's, just the way that my head works. I would I tend to think of that the other way round. I tend to think about if I'm writing the what's the easiest way that I can measure this result that I want to achieve and I let my design choices be driven by that. So if I'm writing a piece of code that's doing something and results in an event being sent sent, I automatically want to separate the concerns of sending the event from generating the the result. So I'm going to be designing to be able to just measure the result in that piece of code and then measuring the sending the message in another piece of code somewhere else is the way that my head goes which is I think I I think is deeply informed by my desire for testability and test-driven development but drives me in the right way of what I would think to be a better factored design as well as a more testable one. >> Yeah,, you're, right., Separation, of concerns. I should have thought of that that that would be a better way to think about it. Yeah. So, uh, it doesn't always go totally smoothly when you're doing TDD. >> Absolutely, not., And, and, and, the, feedback that we get when it screws up is part of the value. >> Yeah., Yeah., So,, I, I, think, I, really, value TDD as a discipline of of making me think about the way I build software in a different way in in small steps. And I think that's that's something people don't see as obvious when they think about TDD. When when you ask someone to describe TDD, they say, "Well, you write the test first." But it's it's about the small steps and forcing you to decompose the problem and and see those green tests every few minutes so that you're you're actually making progress while you're developing. So So when I'm doing TDD at the moment, it's really about knowing whether I expect the test to be passing at the moment, whether I'm refactoring or whether I'm working on the next increment and how long is it since the test last passed. You know that's >> yeah,, those, small, steps, with, confidence. It's be feeling safe while you're making the small steps, isn't it? It be because you get this constant stream of feedback after every small change. I I I was watching some of your stuff about refactoring recently and it was very noticeable the way in which you were making progress in tiny little steps and after each little step you were running the, tests, and, and and, that's, you, know that's that's important. That's it's what this give gives us this this sense of confidence of being able to proceed safely and it's got this side pressure of driving us towards better design. I think something that you said earlier sorry if I could just come back to that is that I don't really know a better way of teaching design than teaching people TDD either. And I think you know if we were to answer this question should TDD be more widely used? Yes, because it would teach people to be better software designers and that's something that we don't talk about enough and don't do enough in our industry. >> Yeah,, there's, an, awful, lot, of, code, out there that you I look at and I'm like goodness me. This is so procedural. There is there is no objects. There's no responsibilities. There's no separation of concerns. And this code is really hard to change safely. >> And, it, would, be, so, much, better, if, if people had actually built it with tests from the start because that would have forced it to happen. So, uh, yeah, it should be used more widely. >> Good. >> Okay., Okay., We, we've, kind, of, we've, got this so much agreement about this. Can we talk about something maybe we we agree less about? Cuz I want to talk about approval testing. >> Okay. >> Uh, cuz, I, think, um, we, talked, about, this before a little bit and I um it's a technique that's very useful in legacy code. Uh you can use an approval testing framework to do characterization testing where you basically pin down the behavior of legacy code. uh and and I use it for that a lot. But you can also use approval tests to drive TDD and it's it's not obvious because of course the thing with an approval test is that the assertion is not defined up front. So it's not canon TDD. You define the the test just as the arrange and the act or the given and the when and then the the actual part that checks what happens isn't defined until the implementation is, finished, or, not, finished, or, at least better. So, um, you get a TDD process where you you um you get a failing test but you you just get this diff to say well, this is what you're actually getting when you ran the test. Is that is that what you wanted? So, it's not it's not um Canon TDD where you you define up front what you expect. But, I find that it works because I guess maybe I'm just cuz I'm used to the rhythm of TDD. you you can still get this very nice feedback cycle going where you're making small steps and the the output you're seeing in the diff is looking better and better and each time you approve it you've got green and you can refactor but it's it's a different kind of, TDD, cuz, in in, in, classic, TDD, you, get this test list and you're kind of crossing things off and you're getting more and more tests in an approval test you you quite often would just like work with one test and and iterate on that one until it looks good basically. So I I what do you think is is I've been trying to convince you here. This is TDD. >> I, I, I'm, afraid, I, was, I, I, still, disagree. So I I am very very grateful to you for introducing me to approval tests in the first place many years ago and I didn't get it at first, but but now I do and I find them extremely valuable and I recommend them almost everywhere for characterization testing. But I confess that I think that you're skipping over an important part of the conversation in your description there. So I was talking to Pratt Dave Thomas a little while ago and he said he doesn't write always write tests anymore and that's because he's done so much TDD that TDD has taught him how to design so he can design pretty well without the tests. And I think you're doing the same thing. I think that absolutely if that's working for you I I can't critique it. it's you're working for you. It's it's it's good. But for me when I'm exploring the problem that I have is that the te an approval test is always based on my solution. It's based on the output from my solution. So sure, I can look at the results of the output from my solution but I could do that in other ways other than approval test and decide whether I like them or not. And that might be useful input, but it doesn't seem like it's the same thing as TDD to me. It's not driving me to design in a certain way. It's not really verifying that I got what I wanted. It's just verifying that I'm still getting what I wanted. And I think that seems like a different thing to me. >> Yeah., So,, I, think, there's, maybe something in what you say because I already know how to design testable code. Uh I don't miss the design pressure from the tests. There is some. Yeah. But okay. Okay. So then the um the question is can you learn to be a good designer without doing it through learning TDD? I mean you probably can but it's a very good way to then learn to be a better software designer. >> I, think, that, you, can, but, I, also, think that you there are things that you all learn from TDD that you won't learn without it that are valuable. I've had the privilege of teaching some extremely good programmers TDD. One of them in particular is is my friend Martin Thompson. I think you know Martin. And Martin Oh, okay. So, so Martin is one of the best programmers in the world. I think anybody that's ever come close to him would agree with that. He's a fantastic programmer and I taught him to do TDD and he and I both think that he's even better now as a result of that. So I think that even for wonderfully talented programmers, TDD is still a powerful tool that will help you to improve to get better insights to the quality of your designs. It sends you we were talking beforehand, it sends you signals. It's the the best tool for giving you feedback on the quality of your design that I know. And it will do that early in the process because as I'm writing a test, I'll start to think you were writing your test with the messaging queue and thinking, I don't like this test. This is too complicated. This is this is getting hard. That was the test screaming at you, change the design. That's what it was doing. It was telling you to stop, you know, stop and think about the design. So, so now I'm going to come come back come to it. And sure, all of us might might go too far down that road, but we're getting the signals. So, we're getting the feedback that now's now's the time to stop and think >> and, to, clean, up, the, design, so, I, don't have this problem. >> How, do, I, avoid, this, problem? >> Yeah., No,, that's, a, really, powerful, story that that that your friend thought he was a better programmer once he'd learned TD even though he was pretty good to start with. >> Yeah., Just, to, be, clear,, Martin's, better than pretty good. >> Yeah., The, other, thing, I, hear, people saying is that it doesn't that they they don't think it's important to write the test first that that they uh will go and write the implementation and write the test afterwards and then just just change something to make sure it fails. So they've seen it fail. So that's and it's it's works as a regression test. So that's the the the argument I've heard and and I'm I can see you smiling. If you didn't use the test to get that feedback while you were designing it. >> Yeah., Then, you, lose, you, lose, much, more than half the value and it's worse than that because as well as not gaining half the value, you lose half the value of the test because now the test that you've written after the fact is tightly coupled to the implementation that you choose to you choose to make. And so all unit testing unit testing is better than no unit testing, but it's not even close to as good as test first test driven development. So unit testing after the fact leads to tests and code deeply entwined and concreted together so that over time projects that work like that concrete together until they're almost impossible to change because if you change the code it fails the test. If you change the test it it's not testing the code properly anymore. And so you can't change anything. And I I've seen that so many times. It's I can remember when I first started doing TDD, we used to have debates about whether test first or not. Now I think it does it's a dumb question because there's no argument test first is test driven and test after is not. So it's not test-driven development unless you write the test first. But in my book anyway >> and, you, cut, yourself, off, from, the opportunity to listen to the feedback in the test that design feedback that you get. Absolutely. >> So, I, think, any, any, approach, to, try, and teach developers test development that doesn't involve writing the test first is is kind of doomed to fail. So TDD is hard to learn though and and people are because that we I think just because we've been taught our entire careers to think about how to implement a thing as being the core of the problem. We we don't naturally always think about how to test the thing as as actually the first step. >> Yes., and, not, not, just, how, to, test, it, but how to specify what we want. We often don't think clearly enough about what it is that we we're aiming to achieve. You know, we start off kind of doing a random walk around their code and writing stuff without really being clear about what it is that we're trying to achieve. One of the disciplines that I value very strongly from test-driven that I've learned from test-driven development is being much clearer about what what it is that I want to achieve with this change, this bit of code whatever it might be. And that seems important. And >> yeah,, and, and, what, is, the, current, focus? What is the slice of this functionality we're doing at the moment? What are the edge cases we're ignoring at the moment because they're on our list, but we're just going to try and get this this part working. So one of the things I found useful when teaching people TDD is getting people to express in first in the test list what is the purpose of this test and then in the actual code when they come to write that test to declare it and write in code comments the what is going to happen in the the uh assertion part. Start with the assertion what should what is going to be true after this and then then get working backwards what is happening in the acts part what is happening in the range part and write that just in code comments before you start to fill in the code because it forces you to just really think through the whole design of the test before you come to write it. So I think it that's that's my bit of advice basically if you're struggling with TDD just try and write the test in comments first. >> Yeah., And, backwards. >> Yeah. >> Yeah., Write, it, backwards, in, comments. Absolutely. Yeah. I I that's that's a piece of advice in my TDD training that I that I offer is start with the assertion because you know what it is that you want to happen. Start with the assertion, then say what triggers the the assertion and then say what state's the system got to be in in order to be able to achieve the assertion. And the test almost write itself. >> Yeah,, I, think, we've, both, spent, a, long time trying to teach people TDD. And it it is yeah, there's various things like that that help you to get the idea and it it takes some time. I mean what what is your experience? How long does it take people to learn TDD? >> I, think, that, there, are, two, levels, at which I'd answer the question. So the first one is that the skills of TDD, I don't think they're that hard. I think you can learn the core skills of TDD probably in a couple of weeks. But the hard part, the thing that trips everybody up is that test-driven development, as we've been discussing puts you face to face with how bad your design skills are. And being good at design is the work of a lifetime. Yeah. >> And, so, you, never, really, you, never, really perfect that. So you we're all learning about how to become better designers. So that goes on forever. And and that's the really difficult part it seems to me. So I I when I teach people TDD, I tend to conscious. So my training course on TDD is called talks about it in terms of design TDD as a tool for designing software. And I I think that's important because that's what we're really learning when we're doing TDD. We're learning how to be better at design because the things that make TDD hard are always about design. Always. It's never anything else. It's it's how we choose to organize the code that makes it hard. So we can fix it by be better at how we choose to organize the code. And that's one of the other reasons why TDD should be so much more widely used >> right?, And, if, it, were, more, widely, used, we'd get better design software that was more flexible and cheaper to change and update and and follow the needs of the business more closely and and more quickly and that is what I think everyone wants. >> Yeah. >> So, that, is, why, TV, should, be, more, widely used. >> At, which, point, that's, probably, a, good place for us to stop. >> Yeah. >> It, was, great, to, chat, with, you, about, this topic, Dave. We we're in so much agreement here and we've got, you know different backgrounds, but we've we've come to a very similar conclusion about this topic. >> I, I, think, so., So,, to, everybody, watching, thank you very much for watching and if you enjoyed the content today, do hit subscribe if you're not already and hit like as well to promote the channel. Thank you and bye-bye.