So [sighs] the bit that people get wrong, the I'll tell you the let me start with the bit that people get right. The bit that people get right is that the point of BDD is communication and the point of BDD is communication in order to get work done. Right? So one of my bug bears I've got a few, things, I'm, I'm I'm, in, my, 50s., I, get to be a bit get off get off my lawn. And one, of the, things, I'm, get, off, my, lawn about is when people say, "Oh, you know the the value of software is in the is in the learning and the point of writing code is in what you learn." I'm like "No, no, I'm not paying you to to learn. I'm paying you to deliver business value to my business and fix problems and stuff. I'm going to assume, unless you're an idiot, that you're likely to learn as you do that. But the point isn't to learn. Learning if you're doing it right is a lovely serendipitous side effect. Right? The point is to get stuff done. And BDD, the way I've always kind of coached BDD is in terms of the next most important thing. What's the next most important thing this doesn't do? Right. What's the next most important thing this doesn't do? How do we articulate that? Yeah. And now and then like the the corollery question is then right. Okay. The next thing it doesn't do is I know it's an ATM. It doesn't give me money or it's ATM. It gives me money but it doesn't give me a receipt or it doesn't do currencies or it doesn't whatever it is I need I care about. The next question then is completeness. Right? So to how how complete do I want the next answer to be? And that's where the scenarios come in. Let's talk about the one where there's money in the machine, the one where there's insufficient money, the one where you're overdrawn, the one where you're not. And all the scenarios that we care about, typically there's a power curve. you know, we get the most important ones first and then there's a diminishing return. Those are the scenarios that we're going to code to that we're going to build. Yeah. We're going to make sure they work and then anything else all bets are off right? If it turns out there's a thing that we didn't cover that you care about, that becomes a scenario. That's a future piece of work. If it accidentally does something cool, great. But don't don't rely on that thing still being there in the next release. Yeah. So I think one of the things when I speak to people about BDD, when I hear about people doing BDD um the thing that still makes me happy is that they understand that it's about getting a bunch of folks to communicate to have a shared understanding in order to get work done. Um the thing that then most people seem to miss, if you like, is that it really isn't about writing plain text files. Yeah, there's this whole thing about I need to give you a little backstory here. There's a whole thing about uh cucumber girkin feature files and it drives me nuts. Uh that drives me nuts for technical like architectural software reasons and it drives me nuts for process reasons. So the technical reasons are this uh actually, bit, of a, backstory., So, cucumber came about uh wonderful wonderful Aselis another excellent worker. Um so ALAC was working at Thoughtworks with me. He got excited about BDD. He was one of the very early adopters. Um some other folks went off and wrote a thing called RSpec which was a BDD framework sort of BD language the given when then type of language or sorry the um the idea of having little little tests in or little examples um in Ruby. And the point about RSpec is again look cuz they already had uh unit a test unit um was that it didn't use the word test and the whole riff on BDD was it was I was just trying to explain what Ken Beck describes by TDD but without using the word test because test confused people. So if I just stopped talking about testing the language ended up as BDD. I I remember having I remember having conversations with you at the time before it before it was written down or you you was kind of fully worked through having conversations about finding a way of teaching TDD better so that people got to the the high ground sooner the good stuff, right? The good stuff. I said, "Oh, you know and honestly, so it starts with uh and it was at uh an an internet bank that we're working at and uh a bunch of smart kids and I'm trying to introduce TDD because I think it's a good way to write software and particularly the thing we're about to do was sort of green fieldish and I thought a great way to start is you mean to go on and I literally I was saying okay so we're going to start with a test and these sort of fairly senior engineers were like we're not writing tests. Yeah. Well, well, I don't really mean a test. What I mean is we've got testers right? They write test. Like, it's not really a test. It's more like you're going, to, describe, what, it's, going to, do. Yeah. But you just said test and you're you're showing us this testing framework. Yeah. And meanwhile, the testers that they had were like, "Do not let the developers write tests. They've got no idea what they're [laughter] doing." So, I said, "Right, okay." And this was like, I, I I, set, myself, a, constraint., Can I describe TDD without once using the word test? Yeah. It's like just a minute, right? No repetition, no debate. [laughter] So I've got to write the word test. We got write describe B without using the word test. So I said, okay, we're going to start by describing what the code's got to do. You know, like normally you'd write a spec. Yeah. Um well, you could either write a spec in Word or you could write it in, this was a net shop, you could write it in C. The cool thing about writing the spec in C is that then you can run it and it can exercise the actual system. And they were like, that sounds pretty cool. Yeah. Yeah. So, basically, we're going to kind of we're going to work our way step by step writing these little code examples that are going to guide the design of the code. And they went "Well, that sounds pretty sensible." And I managed to get them into basically a kind of red green refactor cycle within hours or certainly days without using the word test. And they were off and running and seemed pretty happy. And I was like, "Oh yeah. Was that a fluke? Could I do that?" And right and probably writing better tests. Writing well, they were writing, you know, and I said to them, "I don't remember. But I'm I'm I think this wasn't my line, my language. I think I got this from someone. I suspect it was someone like Tim McKinnon. Mhm. But I started using the phrase model client. So we're writing a little model client. And the point about using the language of model client is when you're describing an API, you're describing it from the client perspective and not the server perspective. Yes. Right. So um so or from the service perspective. And too many service APIs are written from the service perspective rather than from the consumer perspective. And the great thing about writing a model client is you get to be really selfish with the language. I said write it as though the thing exists, as though it was built entirely for you right? If you if if you know your um your hitchhiker's guide to the galaxy I've got my there you go. Um, there's a brilliant moment where Zod Bros climbs out the the correct window of a building into a universe that was entirely designed around him. So, this is it, right? We're going to design We're going to entirely design the universe around the code you're about to write. The API exists. It's the perfect API. It does exactly what you want. It fails in the way you expect. It returns the results the way you expect. Write the code to use that. Okay. Now make it be true. And that was it, right? And we've just written some code. We should probably go tidy up that code. So, write the model client, make it be true, tidy up the code, right? I you you know what I'm describing. Yes. [laughter] But I'm not mentioning any colors or any words beginning with R. Um, and and they were off and running. And I tried this again with another team and it worked. And I was like, this is cool. And and then the the the aha moment was I remember this vivid. I was back in the Thorworks office and also with Chris Mattz who's a business analyst um and I mentioned this thing about writing a example and and he said well you're just describing business analysis so what do you mean he said well we write down what the thing needs to do and we write the acceptance criteria and then some people go build it and then we check it with oh whoa you know and this was where oh no and and right so the other thing that was happening was we were using index cards and Ken Beex talked about this Martin has talked about this. The reason you in fact, I think Ward started this. The reason you use an index card is because it's small. So, you can only write so much on it. And so, on the front of it, you'd write the story, the thing that's going to do. And on the back, uh, Ivan Moore used to write a line down the middle and he'd write, "I do this, this happens." Yeah. I do this. Uh, you know, enter correct username and password. This happens. I get into the good stuff. I do this. Enter an invalid password. this happens, nothing, right? I do this enter an invalid password three times it locks me out. I'm like, that's cool. And so I I said to Chris, this this is what we're doing. And he said, yeah, but that's nonsense. What do you mean? He said, well, I do this, anything could happen. It depends on the context. [clears throat], Like,, oh,, we're, missing context. So, we slid it all across a bit. And that's where the given when then columns came from given, you know the that I've got the correct credentials. And so and so this was our kind of our our template language if you like. Yeah. Um so then so that's going on. I I wrote a thing called Jbehave. Um where I was trying to kind of exercise these ideas in Java. I'm an idiot because what I should have done is based it on JUnit like extended JUnit and then changed it because then it would have just worked in all the IDEs as it was. I tried to do it from scratch and it never caught on. Um Liz K helped with that. She was brilliant. But then uh sometime probably around 2007 I I was doing something and I wanted to have basically like a scenario runner a given when then runner in Ruby. So I wrote one and I wrote it in kind of try to do it in idiomatic Ruby given when then. Um it turns out that uh then is a one of those I think then is a um a keyword in Ruby. So I couldn't just use given when then. And I had to sort of try capital G, capital W, capital T. Um, but I I had this lovely kind of um uh internal DSL where you could write given when then and put blocks of code in there. And I noticed that once you started using the givens in more than one scenario, you could just refer back to them. So you ended up with this lovely fluid kind of easy to process thing. And so I wrote this uh story runner in Ruby and deliberately as a side effect it would document itself. So every step it would also render the name of the step which you can do in Ruby. It's very got lots of lovely reflection stuff. And so then some other folks, David Chilinsky was one of them. Um what's his name? Steve Baker, some other folks uh from the Ruby world uh kind of decided they wanted to roundtrip this. could you write the scenario itself in plain text and then use regular expressions to parse it? And so that that that was a fun thing and they went off and made that be true. Um at which point that's when ASL gets involved and he said, "Yeah, but that's really ugly because you got all these regular expressions around the place. What you actually want is a grammar." So he wrote a little grammar. There's a thing called treetop which is a Ruby grammar processor. And that was the first cut of cucumber was let's take Dan's story runner but have it consume plain text files. Uh at the time I said this is a bad idea. They're like why? Why? You know the BAS can write these now. I said right but they're not going to. A they're not going to. B you've just introduced a whole bunch of levels of indirection. Yeah. Right. So you write the plain text you've now got to write a thing to process that. the steps the D. There's three and four levels of interaction before you get to the code. This clip was taken from my podcast, The Engineering Room with Dave Farley, a monthly podcast with some of the brightest minds in software engineering. You can find full episodes on all your favorite podcast platforms, including Spotify, Apple Podcasts, and Amazon Music. Your support helps us to bring you these regular episodes. So, please leave your positive review on your preferred podcast platform to help us to continue to grow and bring you great guests and their insights. Thank you very much for listening.