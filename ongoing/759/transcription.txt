[Music] Good afternoon everybody. Welcome and thank you so much for joining me here. As you might be able to tell from my accent, I'm not a local. I'm actually from Australia. Um, but I've recently moved to France, which is lovely. Although, it's left my face looking like this because I haven't yet learned how to ask for a beard trim in French. So, if anyone could help me out with that after the talk, that would be great. Um, one of the things I'm excited about today is this is quite a unique talk for this conference. It's uh, one of about five talks that is not about AI. So, let's see how we go with that. We're here to talk about test-driven development and domain driven design. Uh, two topics I really love. So, just a little bit about myself. I was formerly a CTO in Australia. uh co-founded two startups there and these days I work as a coach and adviser to startups but also software teams around quality and architecture and design because one of the things that I think working in that startup space helped me with is really finding my passion in empowering the technology teams to have a meaningful impact on business success and I found these two practices test-driven development and domain driven design to be you know quite relevant in that goal. So today we're going to do some live coding. Well, sort of live coding. I've got it all pre-prepared in a git repository and I'm going to be stepping through the code as we go so that we can build up a pretty meaningful system. Um but also I can show you the flow of how this system evolves as you are using these practices. So let's get right into it. Um we're going to be building a system today that is involved in a pretty standard domain. Uh student registration at a university. Um who's familiar with a diagram like this? seen something like this before. Uh you might call it a domain model. You might call it in the entity relationship diagram. We've got students, they enroll in courses. Uh courses are assigned to rooms. Um and that's actually the the main constraint that we're going to be focused on today is that rooms have a capacity. So, of course, we can't let too many students enroll in a course because uh if we let too many students enroll in a course, then that will exceed the capacity of the room and you'll end up with students that are standing around with tired legs through the course. So, that's not so great. The inspiration for this talk came from uh a conference uh talk I gave about domain driven design where someone said it's a really interesting idea Chris for really complex domains and and big large systems but what if you're starting out building a system you think it's going to be pretty simple and straightforward um maybe that you can just build it with a basic CRUD style um but then later on you find out it's actually more complex than you thought and so that's what's going to happen to us today we're going to start out very simple on the assumption that we can just use simple CRUD practices and we're going to gradually bring in some domain driven design thinking. Um, and particularly when we hit some challenges to sort of turn to domain driven design to help us solve them. So before we get into the code, some some basics. Who in the audience here actually uses test-driven development on a regular basis? Yeah, a couple of hands going up. Um, for those of you who are not familiar with it, it's a pretty straightforward uh practice. We start with uh writing a test first. Um, this is actually kind of fundamental to the technique is that we we write our test first so that we see it go red and then we make the test pass in a very simple way. We try and make it pass as simply as possible and then we take the opportunity to do some refactoring and by iterating the cycle over and over. We gradually build up the application. So now we're going to get into the code. Um before we do though, also I'm curious who practices domain driven design in their workplaces. Slightly less hands. Okay, cool. So this is a beginner's uh talk. Um so if you're kind of curious about these two topics, hopefully this gives you some uh insight into what they're about. Okay, so let me go this way. So code. So how is that from a size perspective? Can the people at the back see? Okay, should I zoom in a bit more? That's some thumbs up. I think I can see. Yep. Cool. just let me know singing out if it becomes too hard and we can zoom in. So we are at the very start of our application. We've got uh no tests and no code literally just uh spring boot initializer setting up a really basic application here. Um so what we're going to be doing is I'm going to be running this script that's going to step us through each of the git commits and I'll sort of show you what happens. So the very first thing we do it's test driven development. We write a test. So our very first test I've written here given I'm a student when I register it should register a new student. We're literally just doing a post uh to the students um path and we're expecting it to register the student which we're encoding as an expectation of a created response. So 2011 HTTP status code. Now when we run this test now as you'd expect it's going to fail because we haven't actually implemented a controller or anything yet. So let's go ahead and implement that so that we can uh move into the green phase. And now we have our student controller. And this is what I mean when I say implement the simplest way that you can make the test pass. The test is asserting nothing more than we get a created response. So that's all the controller is giving us. We're not looking at the payload. Uh we're not looking at headers or anything like that. Uh we're literally just returning a created response at that URL. And that makes the test pass. And so you can see here we're really focusing, at least in the style of TDD that I like to do, very small increment of a test, very small increment of implementation. The other thing I'll draw attention to here, and this is where I start to drip in some of the DDD thinking, is that um this is a controller method. A lot of people would have defaulted to calling this uh create or post. Uh I like to use the language of the domain in my code. In fact, this is a key principle of domain driven design. It's called the ubiquitous language. And the idea is that we learn from our domain experts what language do they use when they're talking about their business domain and then we try and use that language in our code. So even though we're not using proper DDD like we're not doing entities and stuff yet um it's still okay to start to incorporate that language into our code. So we call it register new student. We're going to um add another test here uh and say it should allocate a new ID. So now we're pausing the body uh and looking for the ID on that payload and expecting it to not be an empty UID and not to be null. And now of course our test is gone red again. So let's make this test pass. And now we're returning a new student object with a random UR ID for the ID. One thing I'll draw attention to here is we actually got two classes for the student. One's a student response class in the test and the other is a student class in the um actual application. The reason for separating these and I do see sometimes people sort of inadvertently start using the DTO classes or the the contract classes from their application in their test is that the tests are supposed to represent your consumer of your application. Whether it's an API like we're doing here um or or other kinds of interactions, you want to write your test so that it uh preserves the contract with the consumer. So if you had used the uh class from the application and then you changed that class resulting in a change to the schema, your tests would have continued to pass, but your API consumers would potentially have been broken. So by separating these instances um or these class implementations, we get an extra layer of protection there uh to make sure that we're really intentionally changing our schemas of those uh response payloads. Now we're going to do a little bit of refactoring here. I said it's red green refactor. So I always like to take the opportunity to do some refactoring. And the one that we're doing here um is that before I'll step back so you can see the change. um we were calling our student constructor and passing the ID in. And what we've done with the refactor is just taken the opportunity to use a little bit of that domain language again and create a static factory method on the class. So student register and that encapsulates the um allocation of the ID. This is nice because it starts to give us a place where it makes sense to sort of build up the student object over time. I'd like to do these refactors as soon as I spot the opportunity for them uh in this sort of TDD cycle. Let's move forward here and uh we'll update the tests and now we're asserting that we have a location header. So it should show where to locate the new student. So we're asserting that the location header has the students and the new student ID in it. Now of course this is failing because our controller was not yet setting the header. So let's move forward and now we're sort of building up the URL where the application will be able to find the student uh after retrieving the um location header and now we're returning that in the created response with the new code and student location. And now our tests are passing. I'm not going to spend the whole hour sort of you know doing these incremental little tests but I did want to start in this way to give you all a sense of just really how small these sort of increments can be. It's an interesting thing when we talk about TDD a lot of people jump to the concept of unit tests. Who can tell me what actually is a unit in that phrase unit tests? I know it's a big audience but if anyone can sing out the smallest unit of your software. Yeah, that's an interesting answer. So is that a method? Is it a function? Is it a class? Is it a package? It depends. Ah, you're an architect, right? So I like to think of a unit in TDD as actually not anything to do with the structure of the application, but as a unit of behavior. And so that's why as I add these little incremental slices to the test, I'm actually adding a unit of behavior to the test, the assertion, and then a unit of behavior to the application. And so this explains another thing that I often get questions about with this style is hang on, you've only got one test method and you've got all these different assertions in it. Doesn't that break the sort of test should have one reason to fail phenomenon? And look, that's definitely true and under different circumstances, I might make different trade-offs. Uh, but in this case, the reason I do it in this in this practice is because the when we're testing an API in this way, there's a little bit of overhead to sort of setting up each test. And so having those assertions bundled there uh gives the opportunity to make the most of those uh that overhead and sort of speeds up the tests a little bit. uh it also I think in this style of doing a very small test and having the tests run continuously and then implementing it um the one reason to change phenomena I think that made that made a lot more sense in an environment where you couldn't run all of your tests locally and you had to wait 6 hours for them to run in a CI server because when you get that result back you need to be able to locate exactly where the test failed but in this case because I'm running the test continuously if a test goes red I know exactly what caused it the thing that I just did so there's this opportunity here to take advant antage of um you know modern capabilities uh we're running against an in-memory database or we will be be soon uh to give us a more holistic test around the application uh and not testing yet too far the internal guts of it. There will come a point through this demo where we get get into testing some internal classes and uh we'll talk a little bit about that when we get to that point. So, we're going to update um our test to uh confirm that the response contains some actual details of the student. So, in this case, the name. So, we're returning back the ID, but not the name yet. So, now when we're looking for the name, it's failing. So, let's go back and see how we can handle that. Well, now we can pass the request body and pass in the name into the static factory method that we created before. And we're building up this application step by step. And now that is is passing Next thing I'm going to do actually is a little bit of a side tangent, but um because this concept of the language like the business language and embedding it into your code is so important in domain driven design, I've actually been working on a tool to help with that. Uh it's called contextive and it uh lets you build a glossery in a YAML file in your repository. So in this case, I've added the words student and register. uh with the contextive extension installed into your IDE whether it's Intelligj or VS code at the moment. Um it means you can sort of hover over these terms and you get like a domain definition of that terminology. Um some people say well what's the difference between that and say Java do comment? Java do comments are more for the actual code therefore how does this class works? How do you use the class? Whereas this is really focused on the domain language and how do your business experts talk about the words that they use in their business domain. So you can hover over it in a YAML file, but also you'll see it's here if we hover over this. And because it's just looking for the text that represents that business term, uh it matches the word register and student, and we get the definitions of both of them. Uh which is quite cool. Just recently, I've actually also added um a browser extension uh which allows you to sort of hook into the same uh concept. And we can see here that with the extension installed and now that terminology registered in that YAML file, you can actually get that definition available in the browser and check out exactly um what's going on there. So it's another way to sort of connect the dev teams with the people outside dev, whether it's product or BA or even sales. They can have that extension installed and you can all be working off a common glossery of terminology which I'm really hopeful will help enhance communication and help everyone in uh both teams sort of understand what you're all talking about a little bit more. There's a little side tangent. We get back into the code. Now, I'm actually going to just sort of jump through the next few steps because I want to get a forward to uh you know some of the more interesting stuff because we're just going to right now we're sort of jumping back and forth between the test and the implementation which is exactly how I would do it. Uh but not exactly fascinating watching uh to sort of get through here today. So, we're going to add a test to check for um the registered student details and a simple implementation to add the URL for checking it. So, we're now sort of actually getting a get response here. Jump through a few steps. um asserting the student details as correct, starting to return a response. This is kind of an interesting approach here and something I do quite a lot with TDD is when I first write the test, I do it in such a way that I can actually make the test pass with some hard-coded data. You can see that even though we've got like a a post operation which creates or registers the student uh and a get response to retrieves the student, we actually haven't even saved the student data yet because all of our tests are just using this idea of a test student. Uh we're solving it with hard-coded data. This allows you to build up the structure of the tests and build confidence that the tests are actually asserting on what you want them to and then eventually uh you can do some refactoring on your test side uh to parameterize the test. Let me get down here. So we've got given I've registered when I check my details. So we've created just one parameter for the first student. Make sure that everything is still passing. Add a second parameter which of course now with this value source another student is going to fail because of the hard-coded value. And then finally, the last little piece of the puzzle is that we can add um a JPA repository, save the student, and then retrieve the student. And so this is quite nice because it means that that little step of adding persistence and retrieval was just one tiny little incremental change, the rest of the structure was already in place. And I find that quite a helpful way for work. Uh we're going to start refactoring our tests a little bit to simplify some of the boiler plate that's building up. Um and the URI construction a few of things things. Uh checking for unknown 404 following a very similar pattern. Moving all student tests into a subfolder to sort of group them all together. Checking for unknown gives you a 404. Oh, I'm going backwards. I heard someone chuckling. You spotted it before I did. Thank you. Um, let's step forward a bit more. Now, we're going to start setting up a room, which again, I'm going to jump through this because it follows a very similar uh pattern. Uh, main difference is that when you're setting up the room, you also specify a capacity. Um, but that's not so interesting a difference in terms of the pattern of of implementation. Adding a new ID. Refactoring the static factory method. Getting the room. Inserting the location header. Asserting the details are confirmed. As you can see, very similar pattern. Going to jump through to uh setting up the course, which is where we get to um something a little bit more interesting because we have to actually link that course to a room when we're setting it up. So now we've started to add a course as per the first implementation before literally just returning created response. So let's uh add the course and catalog to the contextive definitions and now allocating the ID. One of the things that's interesting about this style of doing very small tests, very small implementation, and I'm kind of fast forwarding through a few of these things here, is that it often makes me feel a little bit like I'm walking on a tight rope. If I write too big a test, I start to feel like I'm balancing too far in the wrong direction because I know there's going to be a lot of implementation to make up for it. But similarly, if I start building too much on the implementation side, I feel like I'm wobbling too far in the other direction. So, what I really try and focus on when I'm doing these small tests is just that sensation, that experience as you're doing it of just swaying very gently side to side. Little implementation, sorry, little test, little implementation, and back and forth. And it just keeps me confident the whole way through that everything's working well. And of course, uh filtering in a little bit of refactoring as we go. On the refactoring point, I had a very interesting experience a little while ago with my daughter. She was five at the time, and uh we were really struggling to get her to keep her play area tidy. There was just toys everywhere, little bits of plastic and metal and all of the junk. If you're a parent, I'm sure you've seen the same kind of thing. And she never wanted to tidy it. And so one day, we just really sat down. We buckled down. We got her through it. Weeping, wailing, nashing of teeth, all the rest of it. We got to the end of the day. Finally, the area was cleaned up. And she said something to me very profound. She said, "Daddy, next time I'm going to clean it up when it's just a little bit messy because cleaning up when it's really messy is just way too hard." And I thought, "You've just defined TDD to me." And I wish every software team that I've ever worked with could listen to you say that right now because when we let these things accumulate, the croft that we see and we know it's not quite right. We let it accumulate over time, it just gets harder and harder to walk it back. But if you take these opportunities and because you've just written the code and you've just written the test, it's fresh in your mind. You can do the refactoring at the time and keeping your code neat and tidy as you go. Um, since I adopted this style, uh, I've never looked back. It just feels so much better. And a lot of people say, well, we've got to move quickly. We don't have time to write the tests. And I do make this assertion that if you do it in this way and you keep the code clean and tidy and you refactor as you go, then you will make up that time in spades compared to what happens if you don't write the tests and you don't do the refactoring and you start dealing with that croft and accumulation of of structural problems that you've let accumulate over time. Uh this really does make a difference. Okay, so we're setting up a course as I said um uh adding tests for checking them, saving and retrieving courses. You see here we've used the language include the course in the catalog rather than just a post. Similar sort of pattern before is using that DDD ubiquitous language. And now we're starting to specify the room. So we've edited it. So when we include the course in the catalog, we give it a name and also a room ID. But at the moment we don't check that that room exists. Uh so let's add a test uh for when the room ID is not specified. I go down to the down to the tests here. You see the tests have been building up as we've been fast forwarding. But um given I've not set up a room when I include a course in the catalog, I should expect a 4xx response. Um but that is not going to happen. So I'm going to get a failure because it's actually giving me a 200 response because the course controller is literally just including it no matter what room ID I give it. So now we actually have to do a check to say let's um check is the room ID specified on the thing. So a little bit of input validation. So that's just checking does it uh is it actually provided ID. Um then we do a bit of refactoring to use spring boot validation. And let's move forwards uh and test start testing for an unknown um student uh room ID given an incorrect room ID is the new test. An incorrect room ID when I include a new course it should fail. I go back to the course controller and now we're going to actually go and uh check for that room in the room repository. And so now we can say well if the room doesn't exist uh then we should have a bad request because the room ID is uh in the payload not in the URL. Um one thing I've done here is a little bit of refactoring which sometimes a bit controversial for people. Let's go backwards again so you can see it more closely. In this case we're retrieving the room from the room repository. uh and then immediately or else throwing. Now the thing here is it's starting to uh encapsulate some business logic in the controller layer. Um one of the things that I'm going for here, you might sort of notice I've got packages set up by domain concept. Uh this is what's called the vertical slice architecture. Uh who's more familiar with the ports and adapter pattern or hexagonal architecture where you've got like a folder for your controllers, folder for your entities, folder for your persistence. Look, that technique works fine. Um I don't have a problem with it. But one of the things I find is that when I'm engaging with changes that are coming along when the business comes along and says this thing needs to work differently. Say for example the course now has an extra property on it. I'm going to be changing the entity model probably going to be changing the input validation. Maybe changing something around the persistence. And so by grouping everything to do with all of those layers in one folder. Um that vertical slice architecture is keeping that sort of domain concept all grouped together. Um I'm still following uh ports and adapter or hexagonal architecture sort of within the folder. We've separated the controller from the domain model. Um but at this point because we're just doing basic CRUD operations, I haven't separated out a service layer. So some people say to me, why isn't there like a course service or a student service? Honestly, I think it's overhead for this kind of simple CRUD application. Uh maybe as things get a little bit more complex and we've got some more complex workflows, we might find some value in introducing that layer. But by writing the tests at the API, I'm basically giving myself maximum refactorability within the application. Sometimes people have tried TDD and they say to me, "Ah, I kind of liked it, but I got stuck a lot. Every time something changed, I had to go and rewrite all my tests." The problem there is that you've written your tests coupled too tightly to the implementation details. So you've actually made it very hard for you to refactor the application. And those tests have become a disincentive to refactoring by keeping the tests at the contract layer. So what your consumers expect uh you're appropriately protecting the behavior in the way that you've promised outside consumers it's going to behave but giving yourself sort of maximum opportunity to shuffle things around inside the application as you discover new ways of doing it. Um and so that's an explanation for some of the reasons I'm doing it in this way. Uh which you know sometimes people find a little bit strange. Uh so in this case though now I've moved that room and I'm passing in the optional room into the including catalog method uh so that I can actually check uh using a map operation um that it's going to return back an optional uh to the controller as well. And this means now that we can throw the response status exception here, which means we've now got a place where we can put all of the business rules uh without having to check them all uh in this controller level, which is a little bit in that sort of ports and adapter style, keeping the controller focused on mapping the business rules to the technical concerns, the HTTP status codes and so on. Um and keeping the business rules down in that domain model, um where they're sort of encapsulated and agnostic to any technical concerns of how it's represented. going to move forward uh testing unknown courses and so on and uh responding when the 404 when the course ID is not found. So now we've done the basics. If you remember that domain model we had students courses and rooms. We've built up an application in that sort of tick tock TDD style uh where we now have something we can register students. We can uh set up rooms. We can include courses in cataloges and link them to rooms. And now we've got the basics ready to go for the actual operation we care about, which is student enrollment. Uh so we're going to start testing the enrollment process. You can see here we've added um an enrolling operation, enrolling tests, and look, I'm not going to too stress too much about this. We'll sip through a few of these because it's kind of following the same pattern. Tick- tock back and forth. Um adding tests to confirm that there's a successful enrollment, testing for the 404 response, etc. Um, moving forward, testing the ID, passing the student ID in. We're going to end up building something quite similar to what we had before in the enrolling controller, uh, to make sure that we are looking for, you know, does the student exist? Uh, here we go. Student repository, find by ID, does the student exist? And then, uh, checking for the course ID as well. And then checking for the location header. checking the enrollment. Now, this is the very first time we get to sort of actually quite an interesting uh domain rule. Everything else has been CRUD up to this point. Remember, I said that the the premise here is that we're doing something where we thought it was going to be quite simple. And now we've got a test where we're going to be asserting that uh that I'm going to fail my enrollment if the course is full. So, let's check that test out. Given the course I want is full, when I enroll in a course, it should not enroll me. So, there's quite a bit of setup here. We've got to uh set up our room with a capacity of three, uh include our uh course in the catalog, um register three students, and then register our fourth student, and assert that the registration of that fourth student fails. Now, of course, it doesn't fail yet cuz we're not doing any kind of check in the enrolling controller. So, let's take a look at that. As always with TDD, we'll start with a very naive implementation. We're just going to get a count of the number of enrollments. We'll do no enrollments plus one greater than the capacity. Uh then respond with a bad request. And that's great. That makes our test go green. There's an opportunity to refactor here. Um we're going to uh switch the way that we do the count operation. Uh we're going to collapse some of those operations onto the room repository so we're not doing so many database interactions. Um simplify the count operation to use a derived query count there. account by course ID. Uh now we're going to encapsulate the enrollment check onto the room object. So this is starts to push that business logic down into the domain model. So we've got that this is actually the the meaningful business logic this check num enrollments plus one greater than capacity. Uh so having that embedded in the controller and kind of lost amongst all the technical details of different response status codes and stuff is not ideal. Uh so like I said we're doing kind of DDD light at this point. We just push it down into the domain model. give it a name. In the DDD pilots, we would call this an intention revealing method name. So, we're using business language on the on the um method. Uh would enroll enrollment exceed capacity. And it means that in the control, we can kind of read it like a uh the way a business expert would. If the Rome if the room would enrollment capac exceed capacity, uh then we respond with a problem. So, a little bit of refactoring there to make it work. What I would really like to be able to do is just say, you know, course.enroll student, sort of like the ideal expression of the language. Um, but it's not really possible because we still got to do all those data interactions and we do want to keep the database access out of that domain model. Um, so we'll go back to this and we might um introduce something called a domain service. So in this case we're calling it an enrollment service uh an enroller and now we have enroller enroll if enough capacity and that lets us kind of encapsulate these business rules about does the course exist etc. Does the enrollment exceed capacity? And um we can simplify this further by pulling some of these checks out into like a check room capacity method and an enroll method which leaves us with a pretty straightforward implementation. We find the room uh we flat map it to check the room capacity and flatmap it to do the enrollment and then um this kind of operation just passes through the optional nuns if they don't exist. Uh which then allows us to just have a simple response status exception at the top when we catch the or else throw. uh which keeps that sort of domain logic separated from the technical uh details of the of the HTTP controller. Now, this is all going really well. We're pretty proud of ourselves. We've built this enrollment system. We go live with it. Uh and our customers are initially quite happy and then they come to us and say, "There's a bit of a problem. This is not working the way we expected it would. In fact, we had a course last week where there were 21 students in the room, but we only had 20 chairs. What's going on?" And you say, "But that can't be possible. I did TDD. I wrote all the tests. I've got a test that checks that the 21st student cannot enroll. Uh this can't this can't be happening. Um who can tell me why they think that maybe this is allowed to happen in this system right now? Race condition. Yes, I heard the whisper of that over there. So, uh if you're not familiar with what that is, a race condition, two things happening at once. So, these lucky last two students, they both tried to register at once. They both hit the system. Both of them loaded the uh room configuration from the database at the same time. Uh so we're checking the room capacity. We're getting the cap the capacity. Both of them came back with well we've uh got 19 enrollments at this time. They both do the same check. Thumbs up 19 plus one doesn't exceed the capacity and both of their enrollments get persisted. So that's a classic example of a race condition uh where we've got two things happening at once and it causes a problem for the business. So what would you guys do if you hit this situation in the real world? How would you prevent the 21st student from enrolling? What's that? Sorry. Compare and swap. Yeah. So, you can do some sort of smarts um looking in the database after you've uh committed it. Is this what you're referring to? Someone did someone say transactions? Yeah. Pessimistic lock. So, you could lock the database transaction and block the second operation at the database level. You can also do optimistic locking um you know where you're sort of checking version codes and things like this. Um because I'm doing TDD, the very first thing I'm going to do is actually write a test to confirm that I have this. Um so we'll add a concurrency test that says yes, we do have a problem. Uh so given that the course I want is full when I enroll in a course concurrently. So a little trick that I'm doing here to sort of test the concurrency is using the completable futures feature. Um so I'm firing off an enroll and another enroll at the same time. um getting back a completable future and then I'm checking uh with a get the result of that that allows those two API operations to happen concurrently and hopefully now I'll see the test fail but actually as it turns out I haven't seen the test fail because that's the thing about race conditions they're not predictable they don't happen every single time it really depends on really subtle differences in timing so there's actually quite a nice feature uh in Intelligj called uh where you can set it up to test until failure Um if we uh have a look at the configuration here, test until failure, it actually will repeat the tests until there's a failure. So if you do have a race condition, uh I recommend the test and field till failure where we will um see here eventually this enrolling test does actually fail. Um and we'll see here that uh if I expand this out, 35 tests passed. Now I only got 21 tests at the moment. So that 35 is saying it actually took a second run at it um before it had a failure. Sometimes if I rerun this, it'll actually have three goes before it fails. Um but the nice thing is that if you've got a race condition and you do test until fail, you'll almost inevitably uh you know eventually reach the situation where you do get that failure and it gives you confidence when you go and solve the race condition um that things are actually resolved. But luckily in this case before we dive in and start building a lot of complex technical infrastructure to to do a pessimistic optimistic lock or or anything else um we do start to remember that actually maybe this is starting to get to the point where we do need DDD. Remember I said at the start we thought we wouldn't need it. Maybe now DDD could actually help us. So let me go back to our slides. One of the things we're going to do now is because we've realized maybe did we not really understand the requirements properly. One of the techniques from DDD that I like to use is called event storming. Has anyone done eventtor storming in their businesses? Couple of hands going up. So the way to read this is that um this is an eventtorm map. The way it gets created is that you get a bunch of people in a room uh domain experts, technical people. I love to get salespeople, support people, people from all over the business that kind of know what's happening in the day-to-day operations of your company. Get them all together and ask them to prepare this map collaboratively. Now, the process of actually producing it is quite chaotic. Lots of people throwing orange sticky notes up on the walls and then there's a process where you kind of filter it down and get it cleaned up and eventually you arrive at something that helps you understand what it is that people are actually expecting. And the nice thing about this compared to say um this old school uh domain model is that this is a static representation. This doesn't tell me anything about how things change over time or what the business process flow looks like. It just gives me a student, a course, and a room. So with doing the event storming map and we kind of end up in this situation, our domain experts tell us, "No, this isn't this is not what we wanted. This is not what we had in mind. Why why did you build it like this?" And of course, we go back to this and we say, "Well, we we showed you this diagram. We told you what we were going to build." And of course, they say, "Well, is is that what that means? Sorry, we had no idea what you're talking about." Um, so the nice thing about this is that they can kind of follow along. We're using domain language. It goes from left to right, represents the business process. And the thing that they explained to us is that they never really wanted to have to tell us what room a course was in when setting it up. That was an assumption that we made and then they kind of just assumed that it had to be that way for technical reasons. But when you go through this eventtorm map, what they sort of explain is what we'd really like to be able to do is include the courses in the catalog, let the students register, and then work out what courses are most popular. Cuz why would you want to have pre-allocated courses to rooms when you don't know how many students you're going to get? you know, maybe a couple of years ago, introduction to computer science was really popular and now everyone's assuming that agents are going to write all the code, so nobody's signing up for that anymore. Uh, and now everyone's signing up for sort of ancient history. Um, but they've got them in the wrong classes. And so you're going to end up with one course with 100 people registered, but was allocated to a 20 person room. Uh, and another course with five people registered that was allocated to a 100 person room. And it just doesn't make sense from the business perspective. That's not at all what they wanted. And we kind of made that assumption because as technical people we dive straight into a data model, a domain model that we think of in terms of database tables and entities and we weren't thinking about the flow through the process. And so this event storm helps bring that to light and then you sort of realize actually well you don't even really need to set up the rooms right at the start at all. You could move that later in the process and do that in parallel as you start to see which courses are more popular and then we can build auling algorithm uh that will still enforce this constraint. So the interesting thing here is that there this constraint that you can't overfill the room. It's still a real constraint like we're still going to be enforcing that constraint. The question is when in the first concept we were enforcing the constraint at the time of student enrollment and now we understand we can actually enforce the constraint later with a smarter application that's going to actually lead to a better business outcome, more students registering and more satisfied students and even better a simpler system for us. we don't have to worry as much about these technical details. I got some interesting feedback after giving this talk recently where someone got quite frustrated that I use this technique to dodge the hard work of solving a race condition. Um I have to say I'm sorry but I think you might have missed the point. It's not that I can't solve a race condition. I can absolutely and have done that in the past. But uh why would I if actually it's a better business outcome to not even have a race condition at all. So let's go back to our code. Um the next thing we're going to do is actually unwind a few things because we don't need uh some of the things that we did. So we're going to um remove that concurrency test. We don't need it anymore because we're not expecting to have the concurrency. And we're going to start removing some functionality like the things checking the enrollment capacity and so on. There's an interesting step here which is that when you do TDD and you're removing functionality. It turns out that rather than changing the test first, you should actually change the application because the key thing there with TDD, even though we often say it's write the test, write the code, refactor, it's actually more important that it goes red and then green. And so in this case, when you're removing functionality, the way to make it go red is to remove the functionality, let the test go red. then you're confident that you have removed the correct functionality and you haven't left it littered around in the code and then you can remove the test. So now we can remove the test for blocking the enrollment if the capacity is exceeded. Uh we can start removing the functionality for setting the course room ID uh and removing the tests for setting the room ID and then we can start testing ouruling process. Now the first couple of steps here are going to be uh quite similar to what we did before. So, I'll just step through them. But now we're going to get to a point pretty soon uh where we can have an interesting conversation about what level we write our tests at. So, we'll add uh a controller for theuling. Uh we'll add a test for the contents of the schedule response. Um but just like before, I'm going to do it with a hard-coded response. Literally just going to pull out all of the courses and all the rooms. Um and just return that schedule. Set the schedule courses in the response. not going to do any smarts or any algorithm or any kind of intentional allocation of rooms to courses um because right now I'm not re ready to write the tests around that sort of more complex business rule. But what this does give me is confidence of the schema and confidence of the external operation that it's going to need to be performed. But now it's time to actually start to write a thing called a scheduleuler. Um this is the domain service. So it's something that's actually going to encapsulate some business logic and I'm going to start writing some tests that actually directly interact with this class. Now I know I made these comments before that I quite like testing at the API level because it gives me maximum refactorability. Um and to a certain extent in writing this test given a single course in a single room when uh you know it should allocate the courses to the rooms. I've had to make a difficult choice. And there's a trade-off here because as much as it's nice to increase your refactorability, at some point you have to acknowledge that constructing the whole test scenario at the API is quite cumbersome. So that makes it harder to write the tests and it does make it a lot slower to run the test particularly when you've got lots more scenarios that you need to check. So we're going to have a lot of scenarios here. what if there's, you know, different combinations of rooms available and and course um configurations or numbers of enrollments and sorting and sequencing, all that sort of stuff. So now it actually makes sense to dip down a level and start writing what some people would call unit tests. To me, these have all been unit tests. They're units of behavior. But now I'm asserting that unit of behavior at a more fine grain level. So what's the trade-off here? Well, if it turns out later I don't want to use a scheduleuler class. I want to split it into multiple classes. I'm going to have to throw away those tests and rewrite them. But the advantage now is I've got tests that will run more quickly and are easier to set up because now I can just construct this this object course enrollments which gives me the course and the enrollment count and I haven't had to go through the rigma roll of actually registering a whole bunch of students to create that. So I'm kind of inserting myself into the process constructing the input data that I want for this class for thisuling process and passing it straight in. And I think this is a little bit more what people are familiar with when you talk about unit tests, just unit testing a single class. But I really want to make this point that uh this is not what I default to. This is a trade-off that I've made acknowledging the consequences, the reduced refactoraability of the application, but for the benefit of easier test setup and faster running tests. Nothing is a free lunch. You give something, you lose something. But now we can start to write a little bit more um you know test cases. So we've got single course, single room. We can go two courses, two rooms. Now that's going to fail because our very first implementation uh was quite naive and was just sort of effectively zipping them up. But now we can do an implementation that's a little bit more comprehensive. We're going to start sorting the uh courses um and sort the available rooms and now sort of zip them up based on the sort sequence. Extract some methods out. I love these intention revealing names that sort of wrap the individual bits of logic. So we're looking for the smallest available room and we want to assign the courses to the rooms. So the scheduleuler much simpler now we're retrieving the courses by most popular. Uh retrieving the rooms by smallest. Uh we're assigning the courses of the room by using the stream functionality and mapping assign course to room for each course. And then for each course, we're getting um the the course uh getting the the next available room by size, removing that from the available rooms um and returning the course uh that has been allocated to that room. And now test should be passing. We're going to do some refactoring on the test side to um simplify assertions and so on. uh some more uh complexuling results from the API because now we have to wire up this scheduleuler class to our API which we haven't done yet. So if we go back to the scheduleuler controller, we still got that um really naive implementation, but we've got a test now that does check that the results of that scheduleuler algorithm are coming out of the API. And now we can uh implement this much more simply. We get the rooms, we get the enrollments, we pass them into the scheduleuler and return the response and everything's going to be working quite nicely. Now, the very last thing that we're going to do here, um, which is something that, you know, if you are familiar with DDD will be, you know, not too much of a surprise, is that as we were building this up, we were treating these entities as just very simple, um, bags of properties. And the very last thing we've done is we've made all the setters private which is kind of a hallmark of a well-written DDD application because what you're saying is that the state of these entities is protected by the by the by the entity itself. And so all of our state modifications are being done uh with these sort of methods like assign to. Um we're not calling the setter directly. Uh we're doing a domain operation on the entity. And that's starting to bring a little bit more like I said DDD thinking uh into the application. So that brings me to the end of the demo here today. Just to recap, we started out with very lightweight incremental TDD, small test, small implementation. Uh we built up a really simple CRUD application with three endpoints uh so that students could register. We discovered we had a race condition. Uh and rather than diving into a technical solution, we actually stepped back and used DDD to help us find a better business solution, something that was easier to implement and actually led to a better business outcome. I'm going to go back to the slides here. Uh if you'd like to check out this code um you can grab the uh GitHub repository from this QR code and uh it'll allow you to sort of step through each incremental step um and check it all out. Give a few people a moment to grab the QR code there. Um if you're interested in that contextive tool to help you document your business terminology uh and use that in your idees and the browser uh QR code here will take you through to that. And if you'd like to chat with me later, I'll be hanging around outside to chat about any of these topics. If you want to connect on any of the socials, um, here's my details and, uh, yeah, very happy to speak. Thanks once again for having me today. Hope you enjoy the rest of the conference. Cheers. [Music] [Music]