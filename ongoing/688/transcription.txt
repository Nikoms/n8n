cool okay so welcome everyone uh it's cool to see so many people actually found the room unless you actually found the room this morning and never found your way out again because it was sort of a back room I must admit so you're in the room uh with a talk exposing the not so secret practices of the cult of DDD uh if that was not what you intended to see I I I won't be offended if you leave um my name is Chris clug uh I work as a software developer architect consultant uh and public speaker at a company called active solution in Stockholm uh where we do custom development on the Microsoft platform um and I've been doing Dev on net since basically NET Framework 1.1 or one even a little bit um and I I've got this talk because I started reading this book again this time I actually got all the way through it last time I read it which was a few years ago it put me to sleep so many times that I just gave up it was it's it is dry so how many in the room have actually read this book all the way through no yeah um and I started reading that book and I really enjoyed it uh and I think it's fit me better today than it did previously so I actually went through it and realized there is a lot of really good stuff in here and I want to do a talk about it uh but I don't want to go all DD I want to look at the things that are pragma atically possible for a lot of us I actually read that book as well uh so if you are getting into DDD and you want to read books about DDD I would recommend these two books they are at least the blue one is really dry and will put you to sleep unless you happen to be in the right mood in which case it will also put you to sleep but a little bit later the red one is a bit more practical and it's newer so it's kind of more up toate when it looks at the code examples and things like that the uh Eric Evans domain driven design is fairly old and the samples are written in Java most of them uh which is not that hard to read but it feels old I don't know why um but before I go any further I need to put this disclaimer up here I am not going to bash DDD even though the talk is named something like Cult of DDD uh I'm not going to go and say that DDD sucks in anyway uh I think DDD is actually really good I love a lot about DDD so I'm not going to bash it in any way but I'm also not going to tell you that everyone should use DDD because it doesn't fit everyone and that's not in the way that it doesn't just not fit you because you code in a different way or blah you use the wrong language or something like that it's actually a more practical thing so for me I cannot go full DDD the reason for that is that I'm a consultant and I love being consultant because I get to go to companies for both short-term and long-term project and I get to see a lot of different areas and different companies and lot of different cultures and and problems and things like that but it also means that I cannot go DDD because the idea of DDD is about building knowledge about the domain and the ubiquitous language and all of that and no client is going to pay me to spend six months to a year at the company to figure out the business processes and the domain that I'm working in just to go and say hey thanks for the information and then leave I'm too expensive for that unfortunately so for Consultants it's a bit harder so it won't fit everyone but if you're in a product company it might be a little bit easier to go full-blown DDD um but yeah because of that I wanted this talk to be things that we can do even if you don't go Full Tilt DD but I guess we need to have a little quick reap what is DD well domain driven design came out of as I mentioned Eric Evans book tackling complexity at the heart of software of software uh I also had to put two pictures here because the the Portuguese version looks a lot more messy I don't know why it's just funny that they have different covers on the book that's the only one that is different it's the Portuguese one uh everyone everything else is these nice lines and everything like that but apparently coding in Portuguese is is messy um and the book is pretty much from cover to cover about ubiquitous language now I know that I am in a country where English is the native language how many of you are not from the UK anybody okay most of you okay how many of you do not have English as your first language cool how many of you know what ubiquitous means how many of you you know what ubiquitous means meant before you read about the main driven design okay a couple ubiquitous is a weird word uh and I'm from Sweden uh which is probably Apparent from my my English but I had I went online and I I basically pushed punched it into Google to see what's the definition of yurus I kind of understood it but I want to have the real definition and it basically says found everywhere okay so ubiquitous language is a language that is found everywhere but not true because it's actually a language that is found everywhere in the domain that you're working in according to Eric evidence and that's actually not true either because it's it's a language that's available everywhere in a part of the domain you're working on it's not very ubiquitous it is right it's but yeah that's the general gist the ubiquitous language so it is all about the language that they are using in the domain and translating that language into your code so that your code reads in a way that the domain experts can understand what you're doing or at least parts of the domain so for example you go into a meeting you talk to one of the domain experts somebody working at the company and they say based on the client discount we can calculate the total cost of the purchase fairly simple thing right we can all understand that we get aition in our head of this isar un need right or the code un need right to to do that and then we go out in developers and we turn it into once we have the users discount setting we can update the total price on order same thing right it is the same thing it it says the same thing thing it's it's just phrased slightly differently and then we go and Implement that in code and our code ends up looking something like this we get the user ID we get the current order we get the discount setting and we update the current order total price based on the discount setting and then we pull out the total cost how many of you would be okay with this piece of code based on the input that we got from the domain expert yeah pretty much every one of us it's like why not it works it's it compiles and it does what it's supposed to do it does but this is what they said they said you get the current purchase not the current order because purchase and Order are probably interchangeable but they are different words and in the domain we're using the word purchase not order and also we said calculate the cost based on the client's discount now we have calculate total cost instead of update total price and we have a client does discount because it was based on the CL client's discount it wasn't based on the discount setting for the client so once we take that tiny little change we end up with code like this and then all of a sudden we could pretty much show this to a domain expert and say does this look right was this what you said in that meeting that we needed to do and they go yeah sure that looks good highly highly hypothetical and theoretical and probably not going to happen but that's kind of the idea behind the uous language but when you get beyond the uous language or you dive into the books you actually realize that there are things in the books that is beyond or parts of the books but is not jbi's language more technical things that I thought was interesting to turn into a talk because I realized that I use a lot of these technical things in my code on a daily basis and it makes things better in my opinion which and then I thought hey maybe other people can do the same so in the books they're actually called tactical patterns so a tactical pattern is a code pattern that you can use to make it your code more readable more based on uous language things like value objects is talked a lot about in there uh anti-corruption layers which sounds so much cooler than it really is uh domain messages is another thing that the Eric Evans talks a lot about uh but there are also what they call Strategic patterns in there which is more high level like architectural patterns how can we organize things how can we get the architecture to work things like splitting your domain into several subdomains or core supporting generic domains uh bounded contexts is another concept they have in there um and then really generic things that is actually talked about in in the books as well like consistency um it might just be my background as a developer but from what I see we as developer tend to be very happy with the happy case it is so unlikely that our network connection is dropped between point x and point Y because they're just two calls apart but so we just ignore it and then it consistency can be bad there's a lot of talk about how to get better consistency and how to think about consistency in your systems um they talk about layered and hexagonal architecture for example in there um and more but before we dive into these different areas which are bit scattered H there's not going to be like a nice Red Thread running through the whole thing it's just going to be Loosely coupled things but it is important to realize that for domain driven design the technical stuff that we'll be looking at is there to support us to do get a ubiquitous language and a domain model that's beautiful it is not the technical things that are really important just important to get out there they're still the most fun to talk about um Eric quotes it as the the heart of software is its ability to solve domain related problems for its users all other features vital though they may be support this basic purpose and I think that's one thing that developers tend to miss out on and I'm going to say something that might rub a lot of people the wrong way uh and I don't really care because I think I'm the biggest guy in the room um your code has no value anybody disagree actually most people seem to be agreeing or you just don't want to jump up and punch me no the thing is I I firmly believe that our code the code that we write on a daily basis and I write a lot of code has no actual value the value of our code comes out of what the code does not the actual code as such and this this kind of what I'm saying is like code the software is there to S solve domain related problems but that's that's what is there for your code is not the important thing and the technical things we put in there is just to support that thing to support the ability to solve domain related problems now having that said it is just object orienting programming uh that was one of my sort of Awakenings with the books I started reading the books and then I decided to do the talk and I started looking at the things I want to put in the talk and I realized actually very little of this is in any way connected to main driven design it is just the fact that it's actually objectoriented programming and I know that we all think that we're doing object oriented programming cu we're using C which is object oriented and we're doing inherit in some places and then we're doing object-oriented programming not really but you look at it and you can do really beautiful things with objectoriented programming if you just think about actual objects and how to do them and then all of a sudden you start doing weird things like doing internal classes and protected internal and and all of these different things that for most of my programming career was completely useless why would I ever use protected internal it's a weird combination why would I need that and then you start doing actual things with it and you realize oh you can hide things you can make it available but still hiding it for other people so they don't see it and that's kind of where this put me in a position where I care about how everything looks and how everything works uh before I go into my samples once again another disclaimer my examples suck I'm okay with that I don't really care if you have any problems with that I will gladly see you try to do samples that are small enough to fit on one slide in PowerPoint also by the way try coding in PowerPoint it's really hard and second of all has enough information to show off the concept that you want to do which is really hard which is why my examples are contrived they're stupid in every single way and I had to put this disclaimer in there because I have a demo or a sample piece of code that when I ran it in my company that was the only feedback I got that's wrong because in Sweden you have a personal number which is basically every Swedish citizen gets a personal number which is generally based on your birth date and for control digit or four digits afterwards with one control digit at an the end blah blah blah I wrote A simple piece of code to explain that and then they tore me apart because my company produces a new git package that actually handles personal numbers and it's way complex so my samples are contrived they're stupid stupid they're simple but they are there to show you the concept right so here's a bit of code this is actually going to be really hard for you in the back to read I'm sorry for that can you see it okay I got one thumbs up at least so young guy that has good eyes still um how many of you have seen code that looks something like this you go in and you get the the user from a repo you check the inputs you check the first name input the the last name input you check the age and then finally at the end you set the first name last name in the age and then you save the user using the repo anybody seen code like this before anybody write code like this yeah there's nothing wrong I wrote tons of code like this it's there's nothing wrong with it it's just not good sorry to say because it it models responsibilities and it models things in there it's like this method now has validation logic that might need to be reused somewhere else right and it it there's yeah it it complicated so solution to that for a lot of people is removing all of the validation stuff and put that into a validator class so you can reuse the validation right that's really brilliant I like that it's a step in the right direction but once again it forces the user of your user the user of your user class like the developer using your user class needs to remember to call validate first name validate last name validate age before they set the thing which is it's nicer code and it is reusable because this part here in the Middle where it does to validate stuff that's reusable fine one step in the right direction and you can do fluent validation and all of that funky stuff but we've got property Setters right property Setters in C has been there from day one it's part of being an objectoriented language if we move the validation into the setter of our properties it means that we don't have to have a validation class that does the validation for us because it's built in here and it also means that the user of your class doesn't need to remember to call the validation logic it is built into the thing that they're using and all of the sudden your code looks like that nobody's like oh okay who really cares that is much better in my opinion it looks nice I I really like the way that that looks it's a step in the right direction no doubt about it and Eric talks about kind of this thing by saying like the beauty of objects is their ability to encapsulate all that which is the complicated stuff so the client code is simple and can be interpreted in times terms of higher level Concepts so basically when you pull out the code and you start using the user object in this case because of objectoriented programming and using Setters we don't need to know how to do the validation because it comes with the thing that we're using we should make the API for any any class that we're using so simple that you cannot fail using it that is going to be impossible because developers are really good at failing use us things but and they are very creative but it at least pushes them in the right direction right now DD would probably take this one step further and I'm I'm still honestly I'm still getting to this point uh to actually do this but DDD people would be actually step one I will do they will probably look at this and go that's something we do together we update the first name last name of the age that's personal details so we'll introduce a method called update personal Det details once again we are now making it even simpler for the end user to know how to use the user class because if I want to set the username or the name or first name last name or age I call this method and then I can make set the the Setters for my my properties to private set so it's not even possible to modify them without going through this which is basically forcing the developer to do the right thing from the start this I will do and I have done in a lot of cases but didd introduces the idea of value objects now value objects is probably the best thing I think you can take out of this session and bring with you into your code because it is such a cool thing what you do is you basically say that first name last name and age is a value Chris what it's not a value it's three values no it's not it is personal details personal details if I consider them being a thing that is updated together and lives together and always Chang together it can be an object it can be a value so if we create something like this in this case I create a a record so basically I have a record with a Constructor that takes the first name last name and H it has the validation for first name last name and H in here and then there wasn't much more in here but then we have our properties out here first name last name and age and we have in it instead of set on them it means that it's immutable and it means that everything is Inc capitated with all of the validation logic in here which means that we can turn remove that update method we can remove the first name last name and age property of our object we can turn it into a single personal details property and we can make it public get set because being that you cannot create a personal details object that is not valid we don't need to have any valid validation here we can trust the end user to update that object because hey it cannot be created in an invalid state it cannot have a null value in there it cannot have invalid things in there so we can simply go with a single simple property our user class becomes even simpler and updating it is just a matter of doing that or setting it uh or you could potentially use if since we're using records in this case we could use the wi if you want to do it like that so if you want to update instead of setting it but we can basically trust the uh the end user not to be able to screw up your code it's like simplified but still nice value objects have a few characteristics it has three that are important a it has value equality so basically it the way that you compare to Value objects is that you compare every single subproperty of it so the personal details it looks at the first name last name and age and if all those three properties are the same on two objects they are the they are equal they do not do object reference equals immutability you can never modify a value object you create a value object and then if you need a new one you create a new one based on that so you have immutability and this fits very well into C records because records do have value equality by default and they are immutable by default and they have that with keyword for you to be able to modify them and get a new instance back which is pretty nice and they're self validating so you need to have validation in there and if you look at my personal details here because it's a record it's immutable and it has value equality and because I have init Setters down there it is immutable and because I have validation logic in the Constructor it means that um you cannot it it is self validating and can never be created in an inconsistent state so I really love these they are awwesome but there's more to it than just being able to take three properties and make them into one thing and remove a bunch of lines of code in in the user object if you take the the record class or color sorry the color record color the value object color which is one of the the uh value objects that Eric Evan talks about in his book color and we have that in C as well so the color class is a value object it is value equality it is immutable um but it's kind of cool because I have this record color it has a Constructor that has validation for red green blue because I'm doing RGB but then I can do more because I can do things like I have a static from hex method so I can go color from hex and it takes a string and then a bunch of uh string manipulation to figure out the actual values in there to get them out there I can do things like mix with so basically if I have this color over here and then I have this color over here if I mix these two in this ratio I get another another color back so I can can know I can do mixing th things the only thing you need to do then is be smarter than me and figure out how to do the mixing in there but smart people can figure that out but all of these are once again immutable methods so basically they will create a new instance of the thing that you pass in so it doesn't mess with mutability but it gives you help right so here is that class that I wasn't allowed to show at my office this is the way that it works with Swedish personal number numbers I renamed the class so it's now called simplified personal numbers so that I don't offend people at my office um so as I said a Swedish personal number has a date which is the first part of it and then it has four digits at the end uh it is a bit more complicated it has a dash between the two things and if it's a dash you're less than 100 years old and if it's a plus you're over 100 years old really stupid system because it means that you're identifying number in Sweden when you turn 100 it changes and most system don't take that into account so in Sweden when people turn 105 they get an A mail home saying that you are going to go to school and that you're welcome to come to an introductory day at the school this happens over and over and over again because Dash should be a plus anyhow so I got a Constructor here I made it protected because I don't want you to be able to new up one of these uh and it takes a birth date and the four control the digits at the end they're not all control digits but anyway and I I basically can validate those in this Constructor I didn't put in the validate methods but basically you can see they validate the different parts in here so it's self validating and then I create static helper methods so personal number Dot from and I pass in a string because every personal number in Sweden is supposed to be a string with 10 digits with a Dish Dash or a plus or it can be a 12-digit number which is not an official blah blah blah but from a string okay and then we can do from we could do another version down here which is hey I know the birth date uh and then the control digits and all of that but because of the way that personal numbers are structured in Sweden I can use my personal number to figure out your birth date uh I can figure out your legally assigned gender at Birth because one of the numbers appear in the control digits if that is a an odd number you're a girl if you're it's a even number you're a boy so I can figure that out um and then I can give some extra help down here with formatting so it always outputs it in the right format uh in which case 12-digit format is not actually a real format but a lot of people use it anyway so it's more than just encapsulating it's actually helping me with working with that type of value instead of just passing around the string at every single point in time so I like them uh those help us are nice down there as well for the sake of of uh being open here no the birth date is not actually your birth date it can be a a madeup date as well because if you come to Sweden and you don't have any papers of when you were born because you're a refugee for example then you get one out of two dates I think a year and then everybody in those dates it gets too many so they can't do the control digits and then you get another date and it's not your birth date let's just ignore that because you're not from Sweden so you don't have to know that but now being that is being recorded and people at my office might say this I just want to make it clear that I understand how it works um um but they can be even simpler so instead of taking it and saying hey they're good because they can be more more complicated and give you more functionality I can also say they can be even better because they can be even simpler pop Chris what's wrong with this what's wrong with this code nobody yeah so the actual problem it's part the answer was here was uh what does it three and five mean kind of correct the actual problem here is uh it's supposed to be 53 right because the first part is yeah how many of you have written code like this and managed to push in the wrong value at the wrong place how many of you have gone in and updated a method and added another string parameter but you put it in the middle and then your old code still compiles but they come in the wrong way happens all the time you know how simple it is to fix you add that literally that that is all the code you need public record use user ID and public repli group ID and then it takes a value which is to ins in this case because I'm using ins not strings and then your code becomes that which is brilliant and it reads simple now one thing here is that I had somebody suggest might have been me in a not too bright State saying well you could ignore this you could skip this if you just did an implicit cast operator so ins could be turned into these values if you do that you're actually back to square one again and it's just dumb so don't but this is kind of cool and as I said it reads nicely because it basically goes with you create an instance of my item by passing in a user ID in group ID which is literally what it says um and that brings me to what I like uh about DDD as well it's like if you can write code that reads like language it makes it easier to reason about because everybody knows language now the reason I put language in there instead of English is because some people do like to code in their native language which is fine people code with Swedish variable names which is fine because we've got this weird or characters that only exist on our keyboards now the problem with that is that it still doesn't become writing it in Swedish because all the keywords and everything is in English so but if we stick English in there if you can code so that when you use your code it reads like an English sentence it is much easier to work with and much easier to understand what's happening so an example of that is this we get a user repository and then we get a user based we get users uh in the city hille now probably should be double l in h but anyway I hate this piece of code for several reasons first of all I hate that I don't think a that we need to put repository in the name of the interface because if it is a repository you will figure that out because it will have methods that correspond to a repository the fact that you're using a pattern called the repository pattern has nothing to do with your code can we agree on that at least some of you go yeah okay second part is that this pattern is what 25 years old 30 years old and if I ask 10 developers the definition of a repository I am going to get at least eight different answers because 25 or 30 years later we still haven't figured out what a repository pattern actually means and what the definition is so by putting that into your name you're going to end up arguing with your colleagues about what it actually means and whether or not your repository should have a save method or not on it trust me I know because I've been there and the only way to fix it is to have a bigger knife than the guy next to you um the other thing is by removing that it's it becomes I users which I really like and then I tend to actually name my methods on my repositories differently so I name it living in instead of get by City because renaming it to living in means that I can say users in hille equals okay I can't get away from a wait but then users living in HOV it reads like English which then means that it looks nice I kind of like it it's like your code becomes like reading a book kind of not really but you kind of try to get it Le and then my I users repository or I users repository interface becomes with things like with ID with premium subscription with subscription of type living in city with ages between which just reads nicer when you end up using it yes it looks weird in the actual interface but nobody's going to look at the actual interface everybody is going to look at when you use the interface and you press dot what's going to come out in your intelligence because we all depend on that thing folding out and if that comes out and says with premium subscription it's pretty obvious that you are going to get users with premium subscriptions taada that's what I want and then they spend a copious amount of time in the book talking about value objects versus entities or actually they spend a lot of time mostly talking about entities and the difference between a value object and what they call an entity is that an entity has an identity so object that doesn't need to change over time does doesn't need any identity identity is only there for objects that change and because value objects are compared by value not by ID or by reference it means that value objects don't need an ID and they don't change over time they're just a value and you throw it away when you're done with it an entity has an ID because it is a thing that changes over time and we need to track those changes to be able to go in and see what has happened or go in and modify the thing that we're working with and identities are really important like ridiculously important but we as developers have to take a step back and stop putting database integers as the ID for every class we create in some cases it makes sense because it's useful but in a lot of cases it's dumb so this for example if you're once again born in Sweden sorry about my example uh but it was the easiest thing I can it so I found have a Swedish person and I have a database ID and I have a personal number what is the most likely thing that people will use to search for this user in a UI for example the ID or the personal number probably the personal number the ID is a stupid implementation detail we have the ID in the database because we need a way to reference things in the database and have foreign case but and a string like a 12 digit or sorry 13 digigit string is not a good key in a database that's not going to be very useful especially since the personal ID goes from Dash to plus when you're over 100 years old so why not just use the personal number and hide the ID if you need it just put that as a private field instead and then nobody can use it no developer can go and say oh I'm going to use the ID no because the actual natural identifier for a Swedish person is the personal number the actual natural identifier for a car is the vehicle identification number the ACT there are lots of these cases where there's a natural identifier that is much better than the database ID I'm 100% that I have a an integer ID or or a long ID in a database at the Swedish some Swedish government system somewhere but nobody knows that it's not like I'm going to go I'm I'm person 8,664 in the database no I have a personal number that's what we use and since I assume that most of you are net developers considering what conference we are at and that means I assume that a lot of people use Entity framework for doing their database access Entity framework has no problem whatsoever to reference a private field the only thing you do is instead of going property and then Lambda expression to find the ID you put in property of T and you give it a string if the string is a property it or reference is a property it will set the property if it references a private field it will set the private field if it doesn't there's nothing in the class that has the variable name or paret element name underscore ID it will become a shadow property that is managed by identity framework and and Entity framework will do that without a problem so we can do that with Entity framework which then means that no developer can go and say oh I'm going to use the ID because the ID should never be used um and as I said if you go and do this and you just go property of t with ID and you have this class here where there is no ID Entity framework will create a shadow property and it will keep track of that ID inside the DB context without you having to have it on the the actual object which means that it is gone it's never visible but it's still there for your joints and on the topic of Entity framework if you are using value objects that can be used by using complex properties in Entity framework so you can go and say hey I have this thing called personal information it is stored in the same table as my user data but I want to take those columns and turn them into an object of in itself without having a join or anything like that complex properties will do that for you and if you have a really simple value object like the user ID or the the group ID you just do a Hass a conversion and then you can go and actually query in Entity framework and say find all users with user ID X and it will figure out have to take your user ID and turn it into a value that can can query in the database uh so I want you to sort of start your development or I do it at least by designing objects the way that I want them to work I will write my class in the way that I find a an interface for my class that makes sense that logically tells me how to use that thing and then if necessary I adapt that to whatever Entity framework needs so sometimes I will have to do some stuff for Entity framework like foreign case and things but then I do that hidden as much as possible basically putting it in private fields or hiding it in some way so that the user of my object gets a nice simple API that makes sense to figure out how to use the API uh okay so let's zoom out a little bit and look at a slightly bigger picture how many of you have seen this diagram before so there are four hands coming up and about 25 people lying because you have all seen this diagram you cannot be a developer without having seen this I think the first time you open a programming book they basically shove that in your face this is diagram for the start of any architecture basically when you start coding um and it basically says that presentation is allowed to talk to business layer business layer is allowed to talk to P persistence persistence is allowed to talk to to infrastructure um and in the case of DDD well actually oh yeah one thing most most people don't know that this is called a layered architecture that you are not allowed to jump from this layer to that layer just because it's underneath in a layered architecture you only allowed to talk to one layer beneath so that is a nogo in a layered architecture however we're developers so we basically said that we need to be able to go all the way down so we're going to do this anyway we're just going to rename it to a u uh what's it called um sort of like simplified layered architecture or something like that which is basically just we will do this anyway so we'll take the original pattern just say that we're don't care about that thing and then use it anyway and this is fine there's nothing wrong with this uh in any way and DDD talks a lot about um layered architecture like that sorry it's called relaxed layered architecture but they name it slightly different in the name layers so it's presentation application domain and infrastructure those are the layers they've got now this is kind of neat this works not a problem there is one tiny problem though messaging because we are building a lot of distributed systems nowadays which means that there are messages coming in from other things or there there can be other ways to insert information into your code or into your application now the problem with messaging is that it comes in at an infrastructure layer so there's infrastructure that handles messaging so it comes down in down here and then infrastructure needs to go up and tell the application layer that hey I just got a message you need to execute something and then and that isn't allowed right because you're not allowed to go upwards in the stack so the solution to that is you put infrastructure under presentation layer this feels icky uh I don't know why it's just it feels like one of those hey we found a limitation if we just move this thing everything is fine so this is something that actually comes out of the book I'm not making this up this is a suggestion from Eric Evans um that that means that your message comes in at the infrastructure Lev layer which can then call the application layer it can call the domain layer but now you're screwed again because the domain layer now needs to save something which goes up to the infrastructure layer and then you're pooped again you can't do that because you can't go upwards so the solution to that is you keep this layer architecture you do infrastructure under representation and then application and domain and then you make sure that you inject your infrastructure information into the lower layers you make sure that the lower layers depend on abstractions for the infrastructure and then you're good to go because it makes it possible to receive a message on the infrastructure layer going to application going to domain domain calls a local interface which happens to be implemented up here but architecturally it's not going up right because I'm calling something down here sweet now somewhere along the land lines somebody came and said hey I'm going to do it like this instead and I think think this is probably one of the more used models even if a lot of people don't know that they are actually using it it is called um ports and adapters or onion architecture or um it has a bunch of different names but the original name is ports and adapters and the idea here is that we don't think of it as layers going from top to bottom we think of layers going inwards instead so you have an application and then you have inside application you have application services and the application Services talk to domain model and you only talk inwards then you create inputs in different ways they are on the left side of an of a diagram like this so you could have a browser or rest client or a grpc client or potentially a queue or an email or whatever something going into the system and then every one of those ports has an adapter that adapter then takes whatever is coming in from each one of these different clients or these different ports and adapts it into a call to the application Services layer and then the application Services layer talks to The Domain model to basically get stuff done and then the domain model talks to the application Services through those injected interfaces interface implementations to an adapter that then uses a port to talk to Output things which is on the right hand side of your diagram nobody really cares about this diagram but that is kind of what we end up building in most cases today or I do at least H but important to know is that we have the same layering it's the still the same idea that you talk from one layer inwards but you don't talk outwards if you need to talk outwards like from the domain model out to the output ports it is done through an interface that gets injected inwards so basically this you define an interface in your domain model you implement it in some of the outer layers and you inject it into your domain model that means that the domain model doesn't know about anything outside of itself it only knows its own things and then can call the other layers indirectly and then you can also go and say Hey I want to implement my services either in the application Services layer or in the application layer like this so in this case my domain model uses an I email server it only knows about I email server but the actual implementation of iail server is Microsoft 365 email service which then talks to Microsoft 365 um which then kind of means that your application services are allowed to use that implementation they are so your application service could in theory use to domain models I email service but I would recommend that you create your own interface in that layer so that each layer is a separate boundary that doesn't depend on other people's interfaces and then the bigger part of the book talks about the domain and how we turn the domain into a domain driven domain model that we can work with now the problem is with the domain is that it's often very big uh and you have that old saying there's only one way to eat an elephant bite at a time no there is not somebody there's no nobody knows where the quote comes from so if you come and tell me that Nelson Mandela said this he stole it from someone else uh I have checked this the unknown important uh but the reason I bring this up is that I work as a consultant so I generally into new domains all the time and I assume that some of you are Consultants as well anybody quite a few of you how many of you have walked into a client and on day one said sweet I understand this domain it's going to be piece of cake to work with no one how many of you have walked into a client and then left the client that afternoon feeling a bit sweaty and a bit nauseous going I will never understand this because this domain is Bonkers most of us have I just moved into new CL I have a bank as a client right now I'm not a financial it guy at all uh and the domain we're working in is a metad datadriven system on top of a metadata driven system on top of a governance system for the entire Bank it is like that and the only way to solve that is basically break it down into smaller parts and then take one part at a time and fix that and then over time you get to understand the entire thing and the way that DDD does that is that they do divide the domain that you're working in in two different ways so first of all it divides your domain into what is called core domains subdomains and generic subdomains so the core domain is a part of the domain that you are working on that is the most important part for you then you might have other supporting domains so basically we have taken the big domain broken it into smaller pieces and then you work on One Piece and that's your domain but you are still dependent on other domains to get your work done right you cannot live in isolation so you have these supporting subdomains that help you they are important but they're not important to you for for you to build right and then you can depend on what's called generic subdomains which is this is a piece of functionality or a domain that I need to be able to do my piece of code but I'm not building it somebody else is building it but it's also so generic that I can basically go and buy it off the shelf so for example I'm building an eShop I am focused on my eShop functionality but to be able to build my eShop I am going to need a loyalty program and I'm going to use you have some user management now those things are important for my eShop to work but they're not my main concern you can I can build my eShop as I said and I can focus on that but those things are things that other teams in my organization are going to build for me so that I can use them and for them the guys in the Loyalty program that's their core domain and for them the eShop becomes a subdomain that they support and then for my eShop I might need Inventory management and newsletter management but they are generic subdomains because honestly Inventory management is complicated but I can go and buy that off the shelf on the internet and loose letter management I can go and buy that as a service on the internet as well so they are generic subdomains that people that I need to have but somebody else has already solved it so I'm just going to pay for those now inside of a A subdomain or a domain sorry you also have what is called bounded context this is such a weird concept to get your head around when you read the book it took me ages because the hopeful idea of it is that there is one bounded context for each domain but if the domain like a web shop is too big for one team to cover the entire domain you might split your domain into smaller contexts and let one team work on each one of them then you get two bounded context inside of one domain this is a pure practical thing about the fact that you cannot have a team of 60 developers working on the same thing because they're going to cause problems so you split it up into bounded contexts and then you basically say hey we know how these are going to talk to each other so bounded context X so team X is going to work on this part of the domain team Y is going to work on this part of the domain and then they sit down and they agree on how to translate the different things between the different domains so they can work in isolation but they have an agreement on how they do interaction with each other this is kind of good if you have a domain that is too big but you do want to try to avoid it because it makes it more complicated right and the reason for this sort of very strict way of looking at it is in the form of in the world of DDD it also means that there is a ubiquitous language in this bounded context and there is a ubiquitous language in that bounded context even though they're working in the same part of the domain with the same kind of things they have a different ubiquitous language because down here they might have defined that the user has first name and last name and email whereas in this part of the domain i c maybe don't need the email but I need an age instead so at user are two different things here in in the ubiquitous language they have two different definitions but if you ignore the uous language part it's just a matter of taking your domain breaking it into subdomains and then if you need to break those into bounded context and let those teams work freely but make sure that they Comm can communicate bringing it into a 21st century kind of thing thing if you see these as microservices but they're still in the same code base but basically a microservice is the same thing he they can build their thing and they can build their thing as long as they know how to talk together to solve the the end goal right um I do want to mention that defining subdomains in bounded context is really really complicated and Eric Evans is really open about this and he pretty much says that you are going to fail that's just the way it is you will never succeed with this at least not the first try you do and probably not the second third and fifth time you do it in your code base but over time you get better at defining how you can split your entire domain into smaller things that can still work and they are not too dependent on each other but at least take a step back and look at your elephant and sort of go is there a way to split this is there a way to split this into different parts that we can work on individually are there things and this is a thing I think a lot of developers or team teams miss out on is is there a way for us to split off a part and just go and buy that can we not just subscribe to some some online service to do that part of the system so we don't have to build it oh that costs money developers cost money as well in the end building it yourself is going to give you an inferior product at a higher price in most situations uh but then when you split it you have to start talking about communication because these different systems are going to communicate or these different domains so they spend a lot of time talking about um communication in the book uh and here's an example so in my domain I defined order and Order lines but then in my supporting subdomain they decided to build a generic model where you only have item of item types and then items can reference other items of another item type and then there can be an item type order and an item type order line and that makes it very generic and was really useful in this part of the domain really sucks in my part of the domain so the developers tend to do oh I'm just going to go and replicate their model into my model and then whenever I talk to their model their domain I'm going to take what they send back and then I'm going to have these little to item and from item things so I can move from their implementation to my implementation that seems pretty okay until they change their implementation because every time they change their implementation now this part of my application is wrong and needs to be updated as well and then gets even worse when you cannot just go and say hey can you give me this order but because they have built it like this it requires four different web calls to be able to get the thing I need so that I can build up one order with order lines that would suck and would make it complicated to work with and then once again developers tend to go and say sweet we can fix that we put the all of these calls into a service then we just call the service the service does multiple calls and it returns an item and then we use two item from item and we have isolated all the calls which is a step in the right direction and we can then also go and put in what they red on black is bad they we can go go and put in what they call in domain design intention revealing interfaces which is basically we put an interface that reveals what you're what you want to do it's like what do I provide so we name things in a useful way so it makes sense to use the interface but we're still stuck with this kind of annoying part where we have their domain model inside of our domain model as well just to be able to do two item and we have a very hard dependency on if they ever make any change it affects us as well and that is where yeah that was kind of what I wanted to show uh what I just said that's where anti-corruption layers comes in so and in DD they make it a point of making a separate thing to do the conversion so they actually cre create this extra layer in between that knows about two both of the representations and can do the mapping between them but it means that in my domain I call an an intention revealing interface that basically says I want to get an order and then I have this whole piece of code that knows how to get the wrong type the item and item type and do the conversion and everything for me and then give it to my domain that means that my domain is completely separated from this implementation it only knows about order and Order lines and whenever this changes we need to change the anti-corruption layer but our code on that side stays the same and there's only one data model in there does that make sense it's kind of a nice nice way to do it and basically making sure that you push all of that out so your domain is is cleaner and then they talk a lot about asynchronous communication and developers tend to love strong consistency and they want to have it everywhere uh and then you go and talk to the the people the domain experts and they go oh we have that batch job that runs every night yep which means that strong consistency is not a requirement because the currently their system is eventual consistent updating every night which means that we can probably make our system eventually consistent as well which makes us a lot easier to build systems because you can use things like cues to make it more secure and that brings us into messages or events uh that they have in day today they talk a lot about that um and there we've got these events that we generally talk about as developers it's like we send messages between different domains or if you want to call them like we send messages between different microservices or different services in our our architecture to update the information so that we know the data is synchronized between them and everything like that we know these event these events and these messages but they talk or Eric Evan talks about domain events which is a whole different story and really really sweft wa so a domain event is something like this it they are events that happen inside your domain so basically account created or order completed or user account tier changed events and then whenever something like this happens when somebody creates an account you raise this event the account created event and initially nobody cares maybe maybe you just raise that event and it goes into The Ether and nobody cares it's fine but then in the future somebody might care and they can just plug into that and say oh whenever a user account is created we're going to send the welcome email oh whenever a user account is created we need to do X and whenever user account is created and it was created between these two dates they should get a little bonus on their account or whatever and you can just plug in so you basically just do this race event raise the event it goes into something some form of mediator pattern either uh over a service bus or just internally Mo most of the time probably just internally and then when product owner goes and says hey maybe we could get people to keep their Premium Accounts if we offer them a discount on downgrade and the developer just goes hm we have this user account tier changed event I can just plug into that don't need to modify any code just add a piece of code that listens to that event and whenever that event happens we send an email and say hey would you like to stay if we do this can we send everybody a voucher if they buy a blender this week that's a really annoying thing to check in the checkout but then you go H there's this order completed event let's just create a little thing that listens to that event look at the order is there a blender in there yes there is send the voucher and then yeah once you get into messaging you have to start talking about synchronous versus asynchronous communication strong versus evental consistency DDD solves that with aggregate Roots there's only one type of objects or a few types of objects that you pull out of the database you only have a repository for aggregate roots and then if you need to get anything inside the aggregate rout you always go through the aggregate route and then that is the thing that defines a consistent save an aggregate rout is always saved as a unit and that is your consistency boundary this is semi complicated stuff but it's worth reading up on with the agre roots and DDD uh but mainly think about consistency and don't just go it is so unlikely that something happens right here that we can just accept that possibility it's like no make sure that you get consistency if you can or just think about and go no it's too much work to make this 100% consistent we are willing to fix any form of inconsistencies after the fact because the cost of basically mitigating them is too high um and then the last thing is what about consistency with messages and domain events because if you have this situation here we save an entity or an aggregate route and we save that to the database and then inside of a transaction obviously to make sure that everything is saved together and then we send the message message to the message bus now what happens if the message bus is not available because that's going to happen outside of the transaction right so now we have a transaction that's gone through a save that's been done in the repository but an event has not gone out in the service bus so now we have an inconsistent State because the database is updated but everybody in the other services don't know about it or even worse what happens if the network goes down because now we don't know if the message failed to send because the network went down or because we couldn't reach the service bus because it could be that the message went to the service bus and then somebody cut the wire or it could be that the wire was cut to begin with and we couldn't reach the service bus we don't know should we roll back the transaction should we undo our don't know it makes it complicated somebody then says hey let's put the send event inside of the same transaction okay that's kind of cool if your service bus supports distributed transactions like that um but what happens when the entity then fails most service buses will not have like a nice distributed transaction thing so it will just be it will be sent and then if saving it fails then yeah you end up in inconsistent State again and this is actually very simple to fix you use what is called the outbox pattern you basically take your event you save your entity and your event to the database in the same transaction so you know that they are always saved in one place and they're they're consistent and then you create another little tool that goes and looks for the events in the database and push them to the service bus this means that this events will always go go to the service bus with the little caveat that hey doesn't that mean that you still have the problem in the publisher and if the publisher can't send the event then uh it will retry and you might send the message more than once yes that is the way it works and that is the way that messaging works you will always most cases just have a at least once delivery for messages so you need to take that into account that the message might be sent more than one that's just the way it works I also want to quickly I got I'm on the last minute cqrs I just want to mention fits very well into domain driven design uh where you separate the queries and the uh reads or commands and queries sorry um but then the question always comes up if you do cqrs do you need duplicate databases do you have one database that you actually run your transactions again and then you have another read replica that you only do your reads against you can do that or you can just skip it it works fine to do custom reads in the same data store you can make simpler reads in the data store with something like Dapper for example to just get quick read models and then you use Entity framework with a lot more information in it for your queries or your commands so it's fine to run the same database yes there are downsides but it makes a life a lot easier so cqrs with one data store is a nice thing to put into your ddds as well uh having two models will that violate dry princi principle you can take that dry principle and uh yep let's just leave it at that uh we overdo dry in lots of cases to the point as developers we go has to be dry so we have this common class library and then all of a sudden 95% of your code is in that common library because they reuse four lines of code somewhere dry is nice but we can also just go and say in some cases is better for us to replicate code that is not complicated or or very important and replicate that in multiple places instead of basically shoehorning together two things that don't really fit together so dry is not my favorite principle and the goal Eric Evans sums it up nicely with the goal is is that not only can a developer understand what the code does he or she can also understand why it does what it does and can relate the the ongoing communication with the domain experts that's kind of what we want and that's what you can do with these patterns hopefully I want to thank you all for listening I'm two minutes over I'm really sorry about that but you're going to be stuck here anyway because you're not going to be able to find your way out uh feel feel free to leave an eval if you like the session if you didn't like the session I am available come up here and tell me why you didn't like it I will explain why it was great and then you do a great eval so I can come back thank you all so much