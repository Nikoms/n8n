hello everyone and welcome to software architecture Monday my name is Mark Richards and in this lesson number 147 we'll talk about the fallacies of versioning you can find a listing of all the lessons I do in software architecture Monday through my website at developer2architect.com lessons much of the material that I do in software architecture Monday especially of late does come from these two books I wrote with my friend Neil Ford fundamentals of software architecture and also software architecture the hard parts of course today we're going to talk about fallacies and one in particular now back in the mid 90s Peter Deutsch and some other folks from Sun Microsystems coined the eight fallacies of distributed computing and I did a lesson as a matter of fact it was way a long time ago lesson 18 on talking about those fallacies of distributed computing all eight of those fallacies are as valid today as they were back in the mid 90s well it turns out that Neil and I Neil Ford and I have been having some fun uh starting to coin the next eight fallacies of Distributing Computing and as a matter of fact I wanted to offer you up fallacy number nine of distributed computing and that fallacy is that versioning is simple take for example a basic and most basic micro Services ecosystem just with microservices alone we have four main artifacts at a minimum that we have to worry about versioning we may version a particular endpoint on the API Gateway we may version a strict contract for example in Json or XML schema I may have different versions of a service that performs different activities and also versions and multiple versions of shared libraries just in this picture alone we can start to gain an appreciation for some of the complexity that exists with trying to manage different versions for example endpoint 4 talks to schemas one two and three schemas one two and three talk to Services 12.5 12.4 12.3 and 12.2 and all of those use different shared Library versions as well as a matter of fact it could use multiple shared libraries and you can start to see it gets mind-boggling to know what version of different artifacts that particular endpoint actually supports and that's where our challenge occurs oh well let me show you an example of some of the complexities and ways of dealing with some versioning at the higher level than a service let's say that we've got a trading application and I do a post to buy certain stock and so my post is for the app version 1.0 of that endpoint I'm doing a trade and I'm doing a buy now I'd like to buy some Apple stock well it turns out that Apple common stock for example has three different ways of representing it I can represent it by a symbol AAPL I can represent it by what's called a q-sip usually used in the United States and for example 037833 100 or a sea doll which is a lot of times used in Europe the stock exchange daily official list which is 204-6251 well it turns out that all three of these represent the same instrument Apple common stock well here's my current contract now notice on my schema this is a strict contract in Json I've got an account that has to be a number a q-sip that has to be a string shares that have to be a number a minimum of a hundred and all three of these are required so if I've got two consumers and basically the first client here does a post with the accept header on Json for account number one two three four five for that q-sip which is Apple for a thousand of course this passes and perfectly validates and it's fine as does Consumer 2 to purchase 200 shares of Apple stock that works fine as well but what happens if I change my contract from a q-sip to acetall now suddenly consumer one which uses a sea doll works perfectly fine but consumer two who did not know about that change all the sudden breaks well we can fix these kind of problems through versioning it's simple believe me now a fallacy is something that we believe to be true but it's really not and that's what a fallacy is so one approach might be to say well I can version the API so posts for app 1.0 to go to qsips and I can create another endpoint for app 1.1 which uses CDL the problem with this Approach at least in my opinion is I've got two different endpoints for the exact same functionality the only difference here is actually the contract now if I had different trading functionality or I'm trying something new that might warrant a different endpoint version but my preference is to go one step lower and actually apply versioning at the contract level through the header of the request so using the accept header I can use what's called a vendor mime type to actually specify which version of the contract I would like to pass in version one that uses a q-sip version 2 that uses acetall and now consumer one still uses CDLs so notice the vendor mine type here is on version 2 of Json and that works but consumer 2 is still using q-sips to denote that Apple stock and notice the version one right here as opposed to version two and as a matter of fact that now works so this is actually pretty easy solution to this problem and that's exactly where the fallacy of versioning comes in and let me explain the actual service that's now reading in these contracts first has to extract what version of that contract I'm accepting and so I can through regular expression here fairly straightforward and nothing's easy of course but fairly straightforward I get that version but that's where the difficulties begin because now in my service I have to have this kind of code if it's version one then use a q-sip if it's version two use a seed all if it's version three use a symbol if it version 4 and the problem is where do I stop in other words at some point I may not be able to support a prior version just because it breaks our code and that's where the complexities of versioning come in as a matter of fact I'm going to go one step further and show you another fallacy of versioning and it's not simple because I'm talking about the technical aspects right here but then there's the other softer aspects how do I communicate aversion to other teams how do I communicate that I need to deprecate version one of our contract or version 1.1 of our API or version 2.3 of our service or version 5.4 of our shared Library I want to make a change that needs to all be communicated and these type of communication strategies are very difficult not only to create but also to govern and maintain and so we've got a lot of complexities when we start talking about oh just version it and there's a lot to versioning hence why we're calling this the ninth fallacy that versioning is easy all right so fun with kind of fallacies and this has been lesson 147. um you know what I'm going to do in less than 148 I think I'm going to show you fallacy number 10 of distributed computing another fallacy that both Neil Ford and I had coined and so stay tuned in two more Mondays for that next fallacy of distributed computing uh software architecture Monday thank you so much for listening