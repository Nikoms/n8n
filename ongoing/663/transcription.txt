Hello and welcome to software architecture Monday. My name is Mark Richards and in this lesson number 211 I'll talk to you about architectural modularity. The first thing I want to do is talk about the differences between modularity and granularity. Modularity is about the breaking apart of systems into smaller separately deployed units of software. Whereas granularity is about the size of those pieces. And these two things are very much different. As a matter of fact, to show you one of my well-known quotes embrace modularity, but beware of granularity. You see, it's usually with granularity that we get things wrong. And that's what I kind of want to show you a little bit of in this particular lesson. However, in this lesson, what we're going to focus on primarily is modularity. Now, it's sort of undeniable in our industry as a trend right now of basically taking our large monolithic or legacy systems and breaking those apart into separately deployed units of software. Whether it be service-based architecture, microervices, or even eventdriven architecture. What I'd like to do in this lesson is to show you why architectural modularity is important through five main drivers. And that first driver happens to be maintainability. Now maintainability is the ease in which we can apply and locate where to apply those changes in our system. And in a large monolith, it's very difficult to sometimes identify exactly where I should apply a change or a fix to that system. I think I've got all of the areas that need to be changed, but I'm not sure. And as a matter of fact, in a lot of cases, I've been on teams where no one, including myself, actually truly understands the entire codebase for that system. Whereas, if I move to a level of modularity, I go to the unit of software where that change needs change needs to be applied and it's much easier to locate that change. Now, the next driver is testability. Now testability as an architectural characteristic is about two things. It's about the ease of testing but also about the completeness of testing. And when I apply a change in a large monolith, well, I'm not sure if I've broken anything else in that system. Now, certainly I can run some regression tests, all 12,000 of them uh, but that may take several hours or several days. But the key point is this. What I should be testing is the entire system. That really is my testing scope. Whereas if we move to a level of modularity, I apply that same change to a smaller unit of software. Therefore reducing my level of testing scope and reducing the number of unit tests or scenario tests I need to run. The next driver happens to be deployability. Now deployability is about three things. It's about the ceremony involved with deploying our software. It's about the frequency in which I can deploy and also the overall risk. So if I make a change, I have to deploy that entire unit of software. And when we start talking about things like the ceremony involved in deploying a monolith, we may be talking about days of effort. We have code freezes regression tests, uh mock deployments finally going into release. And the frequency a lot of times is weekly or every two weeks or sometimes monthly because of the size of that unit of software. And consequently because of that it's pretty high risk. But if we move to a level of modularity my deployment unit is much smaller. My ceremony is much smaller. As a matter of fact in microservices it may be just a matter of a command line. And as a matter of fact in that case the frequency could be daily and my risk of breaking something else is much less. Now the fourth driver is that of scalability. Now certainly we can scale out large monolithic or legacy systems. But the key point here is it's very expensive and slow because we are scaling out 100% of that functionality even though we only need to scale one small part of that system. Whereas with architectural modularity I can start to scale out only those features or functions I need. Uh the point being I'm scaling at a function level not a system level. And finally uh the last key driver is that of fault tolerance. So let's say that I've got an error here, a fatal error. Uh maybe I'm spinning up a bunch of threads and I run out of memory and that entire monolithic system, that unit of software goes down all functionality. But whereas with architectural modularity, that same exact fault in a service only brings that service down and not impacting any other functionality. It's a good way to think about fault tolerance. Well, I'm missing one key thing here because these are the benefits of architectural modularity. Until this happens all these services start communicating with each other. Maybe it's because I need the functions of another service or maybe I need its data. In which case now we start taking a look at maintainability which goes out the window. Testability which means if I make a change to any of these services, I really should test all of the other services. As a matter of fact, deployability, please don't. We're back to probably weekend deployments because there's too much coupling, too many things I can break. Scalability also goes out the window because if I scale one of these, I have to scale all of them. And finally, if one of these services go down it brings everything to a halt. And so this is a cautionary tale that mostly has to do with granularity, something I'll talk about in a future lesson. So this has been lesson 211. Boy, we're getting up into the 200s now. Um architectural modularity. just some of the drivers of why we move to break apart apart our systems into further smaller separate deployed units of software. So stay tuned next month for another lesson in software architecture Monday.